<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="typescript,手册," />





  <link rel="alternate" href="/atom.xml" title="石进华的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="typescript中文手册">
<meta name="keywords" content="typescript,手册">
<meta property="og:type" content="article">
<meta property="og:title" content="typescript中文手册">
<meta property="og:url" content="http://yoursite.com/2016/07/02/16年/typescript中文手册/index.html">
<meta property="og:site_name" content="石进华的博客">
<meta property="og:description" content="typescript中文手册">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-09-30T01:01:04.963Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="typescript中文手册">
<meta name="twitter:description" content="typescript中文手册">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/07/02/16年/typescript中文手册/"/>





  <title>
    typescript中文手册 | 石进华的博客
</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ea737ca4bb989747a20c011ec2a84d8c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">石进华的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">enjoy every day</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/02/16年/typescript中文手册/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="石进华">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3929251423,454148251&fm=27&gp=0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="石进华的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">typescript中文手册</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-02T04:02:42+08:00">
                2016-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              

              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  27
                </span>
              
            </div>
          

          
              <div class="post-description">
                  typescript中文手册
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。<br>TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var isDone: boolean = false;</div></pre></td></tr></table></figure>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。<br>这些浮点数的类型是<code>number</code>。<br>除了支持十进制和十六进制字面量，Typescript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var decLiteral: number = 6;</div><div class="line">var hexLiteral: number = 0x9837abdef;</div><div class="line">var binaryLiteral: number = 0b0010;</div><div class="line">var octalLiteral: number = 0o74563;</div></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。<br>像其它语言里一样，我们使用string表示文本数据类型。<br>和JavaScript一样，可以使用双引号（”）或单引号（’）表示字符串。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var name: string = &quot;bob&quot;;</div><div class="line">name = &quot;smith&quot;;</div></pre></td></tr></table></figure>
<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。<br>这种字符串是被反引号包围（<code>），并且以</code>${ expr }`这种形式嵌入表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var name: string = `Gene`;</div><div class="line">var age: number = 37;</div><div class="line">var sentence: string = `Hello, my name is $&#123; name &#125;.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I&apos;ll be `$&#123; age + 1 &#125;` years old next month.`;</div></pre></td></tr></table></figure>
<p>这与下面定义sentence的方式效果相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var sentence: string = &quot;Hello, my name is &quot; + name + &quot;.\n\n&quot; +</div><div class="line">    &quot;I&apos;ll be &quot; + (age + 1) + &quot; years old next month.&quot;;</div></pre></td></tr></table></figure>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>TypeScript像JavaScript一样可以操作数组元素。<br>有两种方式可以定义数组。<br>第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var list: number[] = [1, 2, 3];</div></pre></td></tr></table></figure>
<p>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var list: Array&lt;number&gt; = [1, 2, 3];</div></pre></td></tr></table></figure>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>enum类型是对JavaScript标准数据类型的一个补充。<br>像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">enum Color &#123;Red, Green, Blue&#125;;</div><div class="line">var c: Color = Color.Green;</div></pre></td></tr></table></figure>
<p>默认情况下，从0开始为元素编号。<br>你也可以手动的指定成员的数值。<br>例如，我们将上面的例子改成从1开始编号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">enum Color &#123;Red = 1, Green, Blue&#125;;</div><div class="line">var c: Color = Color.Green;</div></pre></td></tr></table></figure>
<p>或者，全部都采用手动赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;;</div><div class="line">var c: Color = Color.Green;</div></pre></td></tr></table></figure>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。<br>例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">enum Color &#123;Red = 1, Green, Blue&#125;;</div><div class="line">var colorName: string = Color[2];</div><div class="line"></div><div class="line">alert(colorName);</div></pre></td></tr></table></figure>
<h4 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h4><p>有时，我们可能会想要为那些在编写程序阶段还不清楚其类型的变量指定一个类型。<br>这些值可能来自于动态的内容，比如来自用户或第三方代码库。<br>这种情况下，我们不希望类型检查器对这些值进行检查或者说让它们直接通过编译阶段的检查。<br>那么我们可以使用any类型来标记这些变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var notSure: any = 4;</div><div class="line">notSure = &quot;maybe a string instead&quot;;</div><div class="line">notSure = false; // okay, definitely a boolean</div></pre></td></tr></table></figure>
<p>在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。<br>你可能认为Object有差不多的作用，就像它在其它语言中那样。<br>但是Object类型的变量只是允许你给它赋任意值 – 但是你不像在它上面调用任意方法，就算它真的包含了这些方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var notSure: any = 4;</div><div class="line">notSure.ifItExists(); // okay, ifItExists might exist at runtime</div><div class="line">notSure.toFixed(); // okay, toFixed exists (but the compiler doesn&apos;t check)</div><div class="line">var prettySure: Object = 4;</div><div class="line">prettySure.toFixed(); // Error: Property &apos;toFixed&apos; doesn&apos;t exist on type &apos;Object&apos;.</div></pre></td></tr></table></figure>
<p>当你只知道数据的类型的一部分时，any类型也是有用的。<br>比如，你有一个数组，它包含了不同的数据类型：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var list: any[] = [1, true, &quot;free&quot;];</div><div class="line"></div><div class="line">list[1] = 100;</div></pre></td></tr></table></figure>
<h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><p>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。<br>当一个函数没有返回值时，你通常会见到其返回值类型是void：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function warnUser(): void &#123;</div><div class="line">    alert(&quot;This is my warning message&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var unusable: void = undefined;</div></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>TypeScript的核心原则之一是对值所具有的shape进行类型检查。<br>它有时被称做“鸭式辨型法”或“结构性子类型化”。<br>在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<h4 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h4><p>下面通过一个简单示例来观察接口是如何工作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function printLabel(labelledObj: &#123; label: string &#125;) &#123;</div><div class="line">  console.log(labelledObj.label);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myObj = &#123; size: 10, label: &quot;Size 10 Object&quot; &#125;;</div><div class="line">printLabel(myObj);</div></pre></td></tr></table></figure>
<p>类型检查器会查看printLabel的调用。<br>printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。<br>需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。</p>
<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">interface LabelledValue &#123;</div><div class="line">  label: string;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function printLabel(labelledObj: LabelledValue) &#123;</div><div class="line">  console.log(labelledObj.label);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myObj = &#123;size: 10, label: &quot;Size 10 Object&quot;&#125;;</div><div class="line">printLabel(myObj);</div></pre></td></tr></table></figure>
<p>LabelledValue接口就好比一个名字，用来描述上面例子里的要求。<br>它代表了有一个label属性且类型为string的对象。<br>需要注意的是，我们在这里并不能像在其它语言里一样，说传给printLabel的对象实现了这个接口。我们只会去关注值的外形。<br>只要传入的对象满足上面提到的必要条件，那么它就是被允许的。  </p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>
<h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>接口里的属性不全都是必需的。<br>有些是只在某些条件下存在，或者根本不存在。<br>可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了“option bags”的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">interface SquareConfig &#123;</div><div class="line">  color?: string;</div><div class="line">  width?: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function createSquare(config: SquareConfig): &#123;color: string; area: number&#125; &#123;</div><div class="line">  var newSquare = &#123;color: &quot;white&quot;, area: 100&#125;;</div><div class="line">  if (config.color) &#123;</div><div class="line">    newSquare.color = config.color;</div><div class="line">  &#125;</div><div class="line">  if (config.width) &#123;</div><div class="line">    newSquare.area = config.width * config.width;</div><div class="line">  &#125;</div><div class="line">  return newSquare;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var mySquare = createSquare(&#123;color: &quot;black&quot;&#125;);</div></pre></td></tr></table></figure>
<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。<br>比如，我们故意将createSquare里的color属性名拼错，就会得到一个错误提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">interface SquareConfig &#123;</div><div class="line">  color?: string;</div><div class="line">  width?: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function createSquare(config: SquareConfig): &#123;color: string; area: number&#125; &#123;</div><div class="line">  var newSquare = &#123;color: &quot;white&quot;, area: 100&#125;;</div><div class="line">  if (config.color) &#123;</div><div class="line">    // Error: Property &apos;collor&apos; does not exist on type &apos;SquareConfig&apos;</div><div class="line">    newSquare.color = config.collor;  // Type-checker can catch the mistyped name here</div><div class="line">  &#125;</div><div class="line">  if (config.width) &#123;</div><div class="line">    newSquare.area = config.width * config.width;</div><div class="line">  &#125;</div><div class="line">  return newSquare;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var mySquare = createSquare(&#123;color: &quot;black&quot;&#125;);</div></pre></td></tr></table></figure>
<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>接口能够描述JavaScript中对象拥有的各种各样的外形。<br>除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。<br>它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface SearchFunc &#123;</div><div class="line">  (source: string, subString: string): boolean;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。<br>下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var mySearch: SearchFunc;</div><div class="line">mySearch = function(source: string, subString: string) &#123;</div><div class="line">  var result = source.search(subString);</div><div class="line">  if (result == -1) &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。<br>比如，我们使用下面的代码重写上面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var mySearch: SearchFunc;</div><div class="line">mySearch = function(src: string, sub: string): boolean &#123;</div><div class="line">  var result = src.search(sub);</div><div class="line">  if (result == -1) &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。<br>如果你不想指定类型，Typescript的类型系统会推断出参数类型，因为函数直接赋值给了SearchFunc类型变量。<br>函数的返回值类型是通过其返回值推断出来的（此例是false和true）。<br>如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与SearchFunc接口中的定义不匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var mySearch: SearchFunc;</div><div class="line">mySearch = function(src, sub) &#123;</div><div class="line">    var result = src.search(sub);</div><div class="line">    if (result == -1) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>与使用接口描述函数类型差不多，我们也可以描述数组类型。<br>数组类型具有一个index类型表示索引的类型，还有一个相应的返回值类型表示通过索引得到的元素的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">interface StringArray &#123;</div><div class="line">  [index: number]: string;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myArray: StringArray;</div><div class="line">myArray = [&quot;Bob&quot;, &quot;Fred&quot;];</div></pre></td></tr></table></figure>
<p>支持两种索引类型：string和number。<br>数组可以同时使用这两种索引类型，但是有一个限制，数字索引返回值的类型必须是字符串索引返回值的类型的子类型。</p>
<p>索引签名能够很好的描述数组和dictionary模式，它们也要求所有属性要与返回值类型相匹配。<br>因为字符串索引表明obj.property和obj[“property”]两种形式都可以。<br>下面的例子里，length的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">interface NumberDictionary &#123;</div><div class="line">  [index: string]: number;</div><div class="line">  length: number;    // 可以，length是number类型</div><div class="line">  name: string       // 错误，`name`的类型不是索引类型的子类型</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h4><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">interface ClockInterface &#123;</div><div class="line">    currentTime: Date;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Clock implements ClockInterface &#123;</div><div class="line">    currentTime: Date;</div><div class="line">    constructor(h: number, m: number) &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">interface ClockInterface &#123;</div><div class="line">    currentTime: Date;</div><div class="line">    setTime(d: Date);</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Clock implements ClockInterface &#123;</div><div class="line">    currentTime: Date;</div><div class="line">    setTime(d: Date) &#123;</div><div class="line">        this.currentTime = d;</div><div class="line">    &#125;</div><div class="line">    constructor(h: number, m: number) &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口描述了类的公共部分，而不是公共和私有两部分。<br>它不会帮你检查类是否具有某些私有成员。  </p>
<p>类静态部分与实例部分的区别</p>
<p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。<br>你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">interface ClockConstructor &#123;</div><div class="line">    new (hour: number, minute: number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Clock implements ClockConstructor &#123;</div><div class="line">    currentTime: Date;</div><div class="line">    constructor(h: number, m: number) &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。<br>constructor存在于类的静态部分，所以不在检查的范围内。  </p>
<p>因此，我们应该直接操作类的静态部分。<br>看下面的例子，我们定义了两个接口，<code>ClockConstructor</code>为构造函数所用和<code>ClockInterface</code>为实例方法所用。<br>为了方便我们定义一个构造函数<code>createClock</code>，它用传入的类型创建实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">interface ClockConstructor &#123;</div><div class="line">    new (hour: number, minute: number): ClockInterface;</div><div class="line">&#125;</div><div class="line">interface ClockInterface &#123;</div><div class="line">    tick();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123;</div><div class="line">    return new ctor(hour, minute);</div><div class="line">&#125;</div><div class="line"></div><div class="line">class DigitalClock implements ClockInterface &#123;</div><div class="line">    constructor(h: number, m: number) &#123; &#125;</div><div class="line">    tick() &#123;</div><div class="line">        console.log(&quot;beep beep&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class AnalogClock implements ClockInterface &#123;</div><div class="line">    constructor(h: number, m: number) &#123; &#125;</div><div class="line">    tick() &#123;</div><div class="line">        console.log(&quot;tick tock&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var digital = createClock(DigitalClock, 12, 17);</div><div class="line">var analog = createClock(AnalogClock, 7, 32);</div></pre></td></tr></table></figure>
<p>因为<code>createClock</code>的第一个参数是<code>ClockConstructor</code>类型，在<code>createClock(AnalogClock</code>, 12, 17)里，会检查<code>AnalogClock</code>是否符合构造函数签名。</p>
<h4 id="扩展接口"><a href="#扩展接口" class="headerlink" title="扩展接口"></a>扩展接口</h4><p>和类一样，接口也可以相互扩展。<br>这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">interface Shape &#123;</div><div class="line">    color: string;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Square extends Shape &#123;</div><div class="line">    sideLength: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var square = &lt;Square&gt;&#123;&#125;;</div><div class="line">square.color = &quot;blue&quot;;</div><div class="line">square.sideLength = 10;</div></pre></td></tr></table></figure>
<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">interface Shape &#123;</div><div class="line">    color: string;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface PenStroke &#123;</div><div class="line">    penWidth: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Square extends Shape, PenStroke &#123;</div><div class="line">    sideLength: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var square = &lt;Square&gt;&#123;&#125;;</div><div class="line">square.color = &quot;blue&quot;;</div><div class="line">square.sideLength = 10;</div><div class="line">square.penWidth = 5.0;</div></pre></td></tr></table></figure>
<h4 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h4><p>先前我们提过，接口能够描述JavaScript里丰富的类型。<br>因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>
<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">interface Counter &#123;</div><div class="line">    (start: number): string;</div><div class="line">    interval: number;</div><div class="line">    reset(): void;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var c: Counter;</div><div class="line">c(10);</div><div class="line">c.reset();</div><div class="line">c.interval = 5.0;</div></pre></td></tr></table></figure>
<p>在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。</p>
<h4 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h4><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。<br>就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。<br>接口同样会继承到类的<code>private</code>和<code>protected</code>成员。<br>这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（<code>implement</code>）。</p>
<p>这是很有用的，当你有一个很深层次的继承，但是只想你的代码只是针对拥有特定属性的子类起作用的时候。子类除了继承自基类外与基类没有任何联系。<br>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Control &#123;  </div><div class="line">    private state: any;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface SelectableControl extends Control &#123;  </div><div class="line">    select(): void;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">class Button extends Control &#123;  </div><div class="line">    select() &#123; &#125;  </div><div class="line">&#125;</div><div class="line">class TextBox extends Control &#123;  </div><div class="line">    select() &#123; &#125;  </div><div class="line">&#125;</div><div class="line">class Image extends Control &#123;  </div><div class="line">&#125;</div><div class="line">class Location &#123;  </div><div class="line">    select() &#123; &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的例子里，<code>SelectableControl</code>包含了<code>Control</code>的所有成员，包括私有成员<code>state</code>。<br>因为<code>state</code>是私有成员，所以只能够是<code>Control</code>的子类们才能实现<code>SelectableControl</code>接口。<br>因为只有<code>Control</code>的子类才能够拥有一个声明于<code>Control</code>的私有成员<code>state</code>，这对私有成员的兼容性是必需的。</p>
<p>在<code>Control</code>类内部，是允许通过<code>SelectableControl</code>的实例来访问私有成员<code>state</code>的。<br>实际上，<code>SelectableControl</code>就像<code>Control</code>一样，并拥有一个<code>select</code>方法。<br><code>Button</code>和<code>TextBox</code>类是<code>SelectableControl</code>的子类（类为它们都继承自<code>Control</code>并有<code>select</code>方法），但<code>Image</code>和<code>Location</code>类并不是这样的。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但这对于熟悉使用面向对象方式的程序员来说有些棘手，因为他们用的是基于类的继承并且对象是从类构建出来的。<br>从ECMAScript 2015，也就是ECMAScript   6，JavaScript程序将可以使用这种基于类的面向对象方法。<br>在TypeScript里，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。  </p>
<h4 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h4><p>下面看一个使用类的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Greeter &#123;</div><div class="line">    greeting: string;</div><div class="line">    constructor(message: string) &#123;</div><div class="line">        this.greeting = message;</div><div class="line">    &#125;</div><div class="line">    greet() &#123;</div><div class="line">        return &quot;Hello, &quot; + this.greeting;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var greeter = new Greeter(&quot;world&quot;);</div></pre></td></tr></table></figure>
<p>如果你使用过C#或Java，你会对这种语法非常熟悉。<br>我们声明一个<code>Greeter</code>类。这个类有3个成员：一个叫做<code>greeting</code>的属性，一个构造函数和一个<code>greet</code>方法。</p>
<p>你会注意到，我们在引用任何一个类成员的时候都用了<code>this</code>。<br>它表示我们访问的是类的成员。</p>
<p>最后一行，我们使用new构造了Greeter类的一个实例。<br>它会调用之前定义的构造函数，创建一个<code>Greeter</code>类型的新对象，并执行构造函数初始化它。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在TypeScript里，我们可以使用常用的面向对象模式。<br>当然，基于类的程序设计中最基本的模式是允许使用继承来扩展一个类。</p>
<p>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">    name:string;</div><div class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</div><div class="line">    move(distanceInMeters: number = 0) &#123;</div><div class="line">        console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Snake extends Animal &#123;</div><div class="line">    constructor(name: string) &#123; super(name); &#125;</div><div class="line">    move(distanceInMeters = 5) &#123;</div><div class="line">        console.log(&quot;Slithering...&quot;);</div><div class="line">        super.move(distanceInMeters);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Horse extends Animal &#123;</div><div class="line">    constructor(name: string) &#123; super(name); &#125;</div><div class="line">    move(distanceInMeters = 45) &#123;</div><div class="line">        console.log(&quot;Galloping...&quot;);</div><div class="line">        super.move(distanceInMeters);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var sam = new Snake(&quot;Sammy the Python&quot;);</div><div class="line">var tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);</div><div class="line"></div><div class="line">sam.move();</div><div class="line">tom.move(34);</div></pre></td></tr></table></figure>
<p>这个例子展示了TypeScript中继承的一些特征，与其它语言类似。<br>我们使用extends来创建子类。你可以看到Horse和Snake类是基类Animal的子类，并且可以访问其属性和方法。</p>
<p>这个例子演示了如何在子类里可以重写父类的方法。<br>Snake类和Horse类都创建了move方法，重写了从Animal继承来的move方法，使得move方法根据不同的类而具有不同的功能。<br>注意，即使tom被声明为Animal类型，因为它的值是Horse，tom.move(34)调用Horse里的重写方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Slithering...</div><div class="line">Sammy the Python moved 5m.</div><div class="line">Galloping...</div><div class="line">Tommy the Palomino moved 34m.</div></pre></td></tr></table></figure>
<h4 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h4><h5 id="默认为公有"><a href="#默认为公有" class="headerlink" title="默认为公有"></a>默认为公有</h5><p>在上面的例子里，我们可以自由的访问程序里定义的成员。<br>如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用public来做修饰；例如，C#要求必须明确地使用public指定成员是可见的。<br>在TypeScript里，每个成员默认为public的。</p>
<p>你也可以明确的将一个成员标记成public。<br>我们可以用下面的方式来重写上面的Animal类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">    public name: string;</div><div class="line">    public constructor(theName: string) &#123; this.name = theName; &#125;</div><div class="line">    move(distanceInMeters: number) &#123;</div><div class="line">        console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="理解private"><a href="#理解private" class="headerlink" title="理解private"></a>理解<code>private</code></h5><p>当成员被标记成<code>private</code>时，它就不能在声明它的类的外部访问。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">    private name: string;</div><div class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">new Animal(&quot;Cat&quot;).name; // Error: &apos;name&apos; is private;</div></pre></td></tr></table></figure>
<p>TypeScript使用的是结构性类型系统。<br>当我们比较两种不同的类型时，并不在乎它们从哪儿来的，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p>
<p>然而，当我们比较带有private或protected成员的类型的时候，情况就不同了。<br>如果其中一个类型里包含一个private成员，那么只有当另外一个类型中也存在这样一个private成员， 并且它们是来自同一处声明时，我们才认为这两个类型是兼容的。<br>对于protected成员也使用这个规则。</p>
<p>下面来看一个例子，详细的解释了这点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">    private name: string;</div><div class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Rhino extends Animal &#123;</div><div class="line">    constructor() &#123; super(&quot;Rhino&quot;); &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Employee &#123;</div><div class="line">    private name: string;</div><div class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var animal = new Animal(&quot;Goat&quot;);</div><div class="line">var rhino = new Rhino();</div><div class="line">var employee = new Employee(&quot;Bob&quot;);</div><div class="line"></div><div class="line">animal = rhino;</div><div class="line">animal = employee; // Error: Animal and Employee are not compatible</div></pre></td></tr></table></figure>
<p>这个例子中有Animal和Rhino两个类，Rhino是Animal类的子类。<br>还有一个Employee类，其类型看上去与Animal是相同的。<br>我们创建了几个这些类的实例，并相互赋值来看看会发生什么。<br>因为Animal和Rhino共享了来自Animal里的私有成员定义private name: string，因此它们是兼容的。<br>然而Employee却不是这样。当把Employee赋值给Animal的时候，得到一个错误，说它们的类型不兼容。<br>尽管Employee里也有一个私有成员name，但它明显不是Animal里面定义的那个。</p>
<h5 id="理解protected"><a href="#理解protected" class="headerlink" title="理解protected"></a>理解<code>protected</code></h5><p>protected修饰符与private修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    protected name: string;</div><div class="line">    constructor(name: string) &#123; this.name = name; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Employee extends Person &#123;</div><div class="line">    private department: string;</div><div class="line"></div><div class="line">    constructor(name: string, department: string) &#123;</div><div class="line">        super(name)</div><div class="line">        this.department = department;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public getElevatorPitch() &#123;</div><div class="line">        return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);</div><div class="line">console.log(howard.getElevatorPitch());</div><div class="line">console.log(howard.name); // error</div></pre></td></tr></table></figure>
<p>注意，我们不能在Person类外使用name，但是我们仍然可以通过Employee类的实例方法访问，因为Employee是由Person派生出来的。</p>
<h5 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h5><p>在上面的例子中，我们不得不定义一个私有成员name和一个构造函数参数theName，并且立刻给name和theName赋值。<br>这种情况经常会遇到。参数属性可以方便地让我们在一个地方定义并初始化一个成员。<br>下面的例子是对之前Animal类的修改版，使用了参数属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">    constructor(private name: string) &#123; &#125;</div><div class="line">    move(distanceInMeters: number) &#123;</div><div class="line">        console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意看我们是如何舍弃了theName，仅在构造函数里使用private name: string参数来创建和初始化name成员。<br>我们把声明和赋值合并至一处。  </p>
<p>参数属性通过给构造函数参数添加一个访问限定符来声明。<br>使用private限定一个参数属性会声明并初始化一个私有成员；对于public和protected来说也是一样。  </p>
<h5 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h5><p>TypeScript支持getters/setters来截取对对象成员的访问。<br>它能帮助你有效的控制对对象成员的访问。</p>
<p>下面来看如何把一类改写成使用get和set。<br>首先是一个没用使用存取器的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Employee &#123;</div><div class="line">    fullName: string;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var employee = new Employee();</div><div class="line">employee.fullName = &quot;Bob Smith&quot;;</div><div class="line">if (employee.fullName) &#123;</div><div class="line">    console.log(employee.fullName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以随意的设置fullName，这是非常方便的，但是这也可能会带来麻烦。</p>
<p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改employee。<br>我们把对fullName的直接访问改成了可以检查密码的set方法。<br>我们也加了一个get方法，让上面的例子仍然可以工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var passcode = &quot;secret passcode&quot;;</div><div class="line"></div><div class="line">class Employee &#123;</div><div class="line">    private _fullName: string;</div><div class="line"></div><div class="line">    get fullName(): string &#123;</div><div class="line">        return this._fullName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    set fullName(newName: string) &#123;</div><div class="line">        if (passcode &amp;&amp; passcode == &quot;secret passcode&quot;) &#123;</div><div class="line">            this._fullName = newName;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            console.log(&quot;Error: Unauthorized update of employee!&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var employee = new Employee();</div><div class="line">employee.fullName = &quot;Bob Smith&quot;;</div><div class="line">if (employee.fullName) &#123;</div><div class="line">    alert(employee.fullName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改employee。</p>
<p>注意：若要使用存取器，要求设置编译器输出目标为ECMAScript 5或更高。</p>
<h5 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h5><p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。<br>我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。<br>在这个例子里，我们使用static定义origin，因为它是所有网格都会用到的属性。<br>每个实例想要访问这个属性的时候，都要在origin前面加上类名。<br>如同在实例属性上使用this.前缀来访问属性一样，这里我们使用Grid.来访问静态属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Grid &#123;</div><div class="line">    static origin = &#123;x: 0, y: 0&#125;;</div><div class="line">    calculateDistanceFromOrigin(point: &#123;x: number; y: number;&#125;) &#123;</div><div class="line">        var xDist = (point.x - Grid.origin.x);</div><div class="line">        var yDist = (point.y - Grid.origin.y);</div><div class="line">        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;</div><div class="line">    &#125;</div><div class="line">    constructor (public scale: number) &#123; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var grid1 = new Grid(1.0);  // 1x scale</div><div class="line">var grid2 = new Grid(5.0);  // 5x scale</div><div class="line"></div><div class="line">console.log(grid1.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;));</div><div class="line">console.log(grid2.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;));</div></pre></td></tr></table></figure>
<h4 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>当你在TypeScript里定义类的时候，实际上同时定义了很多东西。<br>首先是类的实例的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Greeter &#123;</div><div class="line">    greeting: string;</div><div class="line">    constructor(message: string) &#123;</div><div class="line">        this.greeting = message;</div><div class="line">    &#125;</div><div class="line">    greet() &#123;</div><div class="line">        return &quot;Hello, &quot; + this.greeting;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var greeter: Greeter;</div><div class="line">greeter = new Greeter(&quot;world&quot;);</div><div class="line">console.log(greeter.greet());</div></pre></td></tr></table></figure>
<p>在这里，我们写了<code>var greeter: Greeter</code>，意思是<code>Greeter</code>类实例的类型是<code>Greeter</code>。<br>这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p>
<p>我们也创建了一个叫做构造函数的值。<br>这个函数会在我们使用new创建类实例的时候被调用。<br>下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Greeter = (function () &#123;</div><div class="line">    function Greeter(message) &#123;</div><div class="line">        this.greeting = message;</div><div class="line">    &#125;</div><div class="line">    Greeter.prototype.greet = function () &#123;</div><div class="line">        return &quot;Hello, &quot; + this.greeting;</div><div class="line">    &#125;;</div><div class="line">    return Greeter;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">var greeter;</div><div class="line">greeter = new Greeter(&quot;world&quot;);</div><div class="line">console.log(greeter.greet());</div></pre></td></tr></table></figure>
<p>上面的代码里，var Greeter将被赋值为构造函数。<br>当我们使用new并执行这个函数后，便会得到一个类的实例。<br>这个构造函数也包含了类的所有静态属性。<br>换个角度说，我们可以认为类具有实例部分与静态部分这两个部分。  </p>
<p>让我们来改写一下这个例子，看看它们之前的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Greeter &#123;</div><div class="line">    static standardGreeting = &quot;Hello, there&quot;;</div><div class="line">    greeting: string;</div><div class="line">    greet() &#123;</div><div class="line">        if (this.greeting) &#123;</div><div class="line">            return &quot;Hello, &quot; + this.greeting;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            return Greeter.standardGreeting;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var greeter1: Greeter;</div><div class="line">greeter1 = new Greeter();</div><div class="line">console.log(greeter1.greet());</div><div class="line"></div><div class="line">var greeterMaker: typeof Greeter = Greeter;</div><div class="line">greeterMaker.standardGreeting = &quot;Hey there!&quot;;</div><div class="line">var greeter2:Greeter = new greeterMaker();</div><div class="line">console.log(greeter2.greet());</div></pre></td></tr></table></figure>
<p>这个例子里，greeter1与之前看到的一样。<br>我们实例化Greeter类，并使用这个对象。<br>与我们之前看到的一样。</p>
<p>再之后，我们直接使用类。<br>我们创建了一个叫做<code>greeterMaker</code>的变量。<br>这个变量保存了这个类或者说保存了类构造函数。<br>然后我们使用<code>typeof Greeter</code>，意思是取<code>Greeter</code>类的类型，而不是实例的类型。<br>或者理确切的说，”告诉我Greeter标识符的类型”，也就是构造函数的类型。<br>这个类型包含了类的所有静态成员和构造函数。<br>之后，就和前面一样，我们在greeterMaker上使用new，创建Greeter的实例。</p>
<h4 id="把类当做接口使用"><a href="#把类当做接口使用" class="headerlink" title="把类当做接口使用"></a>把类当做接口使用</h4><p>如上一节里所讲的，类定义会创建两个东西：类实例的类型和一个构造函数。<br>因为类可以创建出类型，所以你能够在可以使用接口的地方使用类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">    x: number;</div><div class="line">    y: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Point3d extends Point &#123;</div><div class="line">    z: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;;</div></pre></td></tr></table></figure>
<p>关于术语的一点说明:   </p>
<blockquote>
<p>必须要注意一点在TypeScript 1.5里，术语名称已经发生了变化。<br>“Internal modules” 现在叫做 “namespaces”。<br>“External modules” 现在则简称为 “modules”，为了与ECMAScript 2015里的术语保持一致，(也就是说 module X { 相当于现在推荐的写法 namespace X {)。<br>命名空间/模块 介绍</p>
</blockquote>
<p>这篇文章将概括介绍在TypeScript里使用模块与命名空间组织代码的方法。<br>我们也会谈及命名空间和模块的高级使用场景，并指出在使用它们的过程中常见的陷井。  </p>
<p>查看模块章节了解关于模块的更多信息。<br>查看命名空间章节了解关于命名空间的更多信息。</p>
<h3 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h3><p>命名空间是在全局命名空间里的一个有名字的JavaScript普通对象。<br>这令命名空间十分容易使用。<br>它们可以在多文件中同时使用，并通过–outFile结合在一起。<br>命名空间是帮助你组织Web应用的好助手，可以把所有依赖都放在页面的<script>里。  </p>
<p>但就像其它全局命名空间污染一样，这很难去了解组件之间的依赖关系，尤其是在大型的应用中。</p>
<h4 id="拥抱模块化"><a href="#拥抱模块化" class="headerlink" title="拥抱模块化"></a>拥抱模块化</h4><p>像命名空间一样，模块可以包含代码和声明。<br>不同的是模块可以声明它的依赖。  </p>
<p>模块也会把依赖添加到模块加载器上（例如CommonJs/requirejs）。<br>对于小型的JS应用来说这可能是不必要的，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。<br>模块也提供了更好的代码重用，更强的封闭性和更好的支持用工具进行优化。</p>
<p>对于Node.js应用来说，模块是默认的并组是推荐的组织代码的方式。</p>
<p>从<code>ECMAScript 2015</code>开始，模块成为了语言内置的部分，应该会被所有正常的解释引擎所支持。</p>
<p>对于新的项目来说模块应该是首选组织代码的形式。</p>
<p>命名空间和模块的陷井</p>
<p>这部分我们会描述常见的命名空间和模块的使用陷井，和怎样去避免它。</p>
<p>对模块使用/// <reference></p>
<p>一个常见的错误是使用/// <reference>引用模块文件，应该使用import。<br>要理解这之间的不同，我们首先应该弄清编译器定位模块类型信息的3种方法。</p>
<p>首先，根据import x = require(…);声明查找.ts文件。<br>这个文件应该是使用了顶层import或export声明的具体实现文件。</p>
<p>其次，与前一步相似，去查找.d.ts文件，不同的是它不是具体实现文件而是声明文件（同样具有顶级的import或export声明）。</p>
<p>最后，是查找“外部模块的声明”，它是通过declare和使用被引号括住的名字定义的。</p>
<p><code>myModules.d.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// In a .d.ts file or .ts file that is not a module:</div><div class="line">declare module &quot;SomeModule&quot; &#123;</div><div class="line">    export function fn(): string;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>myOtherModule.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/// &lt;reference path=&quot;myModules.d.ts&quot; /&gt;</div><div class="line">import m = require(&quot;SomeModule&quot;);</div></pre></td></tr></table></figure>
<p>这里的引用标签指定了外来模块的位置。<br>这就是一些Typescript例子中引用node.d.ts的方法。</p>
<h4 id="不必要的命名空间"><a href="#不必要的命名空间" class="headerlink" title="不必要的命名空间"></a>不必要的命名空间</h4><p>如果你想把命名空间转换为模块，它可能会像下面这个文件一件：</p>
<p><code>shapes.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export namespace Shapes &#123;</div><div class="line">    export class Triangle &#123; /* ... */ &#125;</div><div class="line">    export class Square &#123; /* ... */ &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>顶层的模块Shapes包裹了Triangle和Square。<br>这对于使用它的人来说是让人迷惑和讨厌的：</p>
<p><code>shapeConsumer.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import shapes = require(&apos;./shapes&apos;);</div><div class="line">var t = new shapes.Shapes.Triangle(); // shapes.Shapes?</div></pre></td></tr></table></figure>
<p>TypeScript里模块的一个特点是不同的模块永远也不会在相同的作用域内使用相同的名字。<br>因为使用模块的人会为它们命名，所以完全没有必要把导出的符号包裹在一个命名空间里。</p>
<p>再次重申，不应该对模块使用命名空间，使用命名空间是为了提供逻辑分组和避免命名冲突。<br>模块文件本身已经是一个逻辑分组，并且它的名字是由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层。</p>
<p>下面是改进的例子：</p>
<p><code>shapes.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export class Triangle &#123; /* ... */ &#125;</div><div class="line">export class Square &#123; /* ... */ &#125;</div></pre></td></tr></table></figure>
<p><code>shapeConsumer.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import shapes = require(&apos;./shapes&apos;);</div><div class="line">var t = new shapes.Triangle();</div></pre></td></tr></table></figure>
<h3 id="模块的取舍"><a href="#模块的取舍" class="headerlink" title="模块的取舍"></a>模块的取舍</h3><p>就像每个JS文件对应一个模块一样，TypeScript里模块文件与生成的JS文件也是一一对应的。<br>这会产生一个效果，就是无法使用–out来让编译器合并多个模块文件为一个JavaScript文件。</p>
<p>关于术语的一点说明:   </p>
<blockquote>
<p>必须要注意一点在TypeScript 1.5里，术语名称已经发生了变化。<br>“Internal modules” 现在叫做 “namespaces”。<br>“External modules” 现在则简称为 “modules”，为了与ECMAScript 2015里的术语保持一致，(也就是说 module X { 相当于现在推荐的写法 namespace X {)。<br>命名空间 介绍</p>
</blockquote>
<p>这篇文章描述了如何在TypeScript里使用命名空间（之前叫做“内部模块”）来组织你的代码。</p>
<p>就像我们在术语说明里提到的那样，“内部模块”现在叫做“命名空间”。</p>
<p>另外，任何使用module关键字来声明一个内部模块的地方都应该使用namespace关键字来替换。</p>
<p>这就避免了让新的使用者被相似的名称所迷惑。</p>
<h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p>我们先来写一段程序并将在整篇文章中都使用这个例子。<br>我们定义几个简单的字符串验证器，假设你会使用它们来验证表单里的用户输入或验证外部数据。</p>
<p>所有的验证器都放在一个文件里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">interface StringValidator &#123;</div><div class="line">    isAcceptable(s: string): boolean;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var lettersRegexp = /^[A-Za-z]+$/;</div><div class="line">var numberRegexp = /^[0-9]+$/;</div><div class="line"></div><div class="line">class LettersOnlyValidator implements StringValidator &#123;</div><div class="line">    isAcceptable(s: string) &#123;</div><div class="line">        return lettersRegexp.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ZipCodeValidator implements StringValidator &#123;</div><div class="line">    isAcceptable(s: string) &#123;</div><div class="line">        return s.length === 5 &amp;&amp; numberRegexp.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Some samples to try</div><div class="line">var strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];</div><div class="line">// Validators to use</div><div class="line">var validators: &#123; [s: string]: StringValidator; &#125; = &#123;&#125;;</div><div class="line">validators[&quot;ZIP code&quot;] = new ZipCodeValidator();</div><div class="line">validators[&quot;Letters only&quot;] = new LettersOnlyValidator();</div><div class="line">// Show whether each string passed each validator</div><div class="line">strings.forEach(s =&gt; &#123;</div><div class="line">    for (var name in validators) &#123;</div><div class="line">        console.log(&quot;&quot;&quot; + s + &quot;&quot; &quot; + (validators[name].isAcceptable(s) ? &quot; matches &quot; : &quot; does not match &quot;) + name);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们的类型的同时还不用担心与其它对象产生命名冲突。<br>因此，我们把验证器包裹到一个命名空间内，而不是把它们放在全局命名空间下。</p>
<p>下面的例子里，把所有与验证器相关的类型都放到一个叫做Validation的命名空间里。<br>因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用export。<br>相反的，变量lettersRegexp和numberRegexp是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。<br>在文件末尾的测试代码里，由于是在命名空间之外访问，因此需要限定类型的名称，比如<code>Validation.LettersOnlyValidator</code>。</p>
<h4 id="使用命名空间的验证器"><a href="#使用命名空间的验证器" class="headerlink" title="使用命名空间的验证器"></a>使用命名空间的验证器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">namespace Validation &#123;</div><div class="line">    export interface StringValidator &#123;</div><div class="line">        isAcceptable(s: string): boolean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    const lettersRegexp = /^[A-Za-z]+$/;</div><div class="line">    const numberRegexp = /^[0-9]+$/;</div><div class="line"></div><div class="line">    export class LettersOnlyValidator implements StringValidator &#123;</div><div class="line">        isAcceptable(s: string) &#123;</div><div class="line">            return lettersRegexp.test(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    export class ZipCodeValidator implements StringValidator &#123;</div><div class="line">        isAcceptable(s: string) &#123;</div><div class="line">            return s.length === 5 &amp;&amp; numberRegexp.test(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Some samples to try</div><div class="line">var strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];</div><div class="line">// Validators to use</div><div class="line">var validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;</div><div class="line">validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();</div><div class="line">validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();</div><div class="line">// Show whether each string passed each validator</div><div class="line">strings.forEach(s =&gt; &#123;</div><div class="line">    for (var name in validators) &#123;</div><div class="line">        console.log(`&quot;$&#123; s &#125;&quot; - $&#123; validators[name].isAcceptable(s) </div><div class="line">        ? &quot;matches&quot; : &quot;does not match&quot; &#125; $&#123; name &#125;`);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="分离到多文件"><a href="#分离到多文件" class="headerlink" title="分离到多文件"></a>分离到多文件</h4><p>当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。</p>
<h4 id="多文件中的命名空间"><a href="#多文件中的命名空间" class="headerlink" title="多文件中的命名空间"></a>多文件中的命名空间</h4><p>现在，我们把Validation命名空间分割成多个文件。<br>尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。<br>因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。<br>我们的测试代码保持不变。</p>
<p><code>Validation.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">namespace Validation &#123;</div><div class="line">    export interface StringValidator &#123;</div><div class="line">        isAcceptable(s: string): boolean;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LettersOnlyValidator.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</div><div class="line">namespace Validation &#123;</div><div class="line">    const lettersRegexp = /^[A-Za-z]+$/;</div><div class="line">    export class LettersOnlyValidator implements StringValidator &#123;</div><div class="line">        isAcceptable(s: string) &#123;</div><div class="line">            return lettersRegexp.test(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ZipCodeValidator.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</div><div class="line">namespace Validation &#123;</div><div class="line">    const numberRegexp = /^[0-9]+$/;</div><div class="line">    export class ZipCodeValidator implements StringValidator &#123;</div><div class="line">        isAcceptable(s: string) &#123;</div><div class="line">            return s.length === 5 &amp;&amp; numberRegexp.test(s);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Test.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</div><div class="line">/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;</div><div class="line">/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;</div><div class="line"></div><div class="line">// Some samples to try</div><div class="line">var strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];</div><div class="line">// Validators to use</div><div class="line">var validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;</div><div class="line">validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();</div><div class="line">validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();</div><div class="line">// Show whether each string passed each validator</div><div class="line">strings.forEach(s =&gt; &#123;</div><div class="line">    for (var name in validators) &#123;</div><div class="line">        console.log(&quot;&quot;&quot; + s + &quot;&quot; &quot; + (validators[name].isAcceptable(s) ? &quot; matches &quot; : &quot; does not match &quot;) + name);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。<br>我们有两种方式。</p>
<p>第一种方式，把所有的输入文件编译为一个输出文件，需要使用–out标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tsc --outFile sample.js Test.ts</div></pre></td></tr></table></figure>
<p>编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts</div></pre></td></tr></table></figure>
<p>第二种方式，我们可以编译每一个文件（默认方式），那么每个源文件都会对应生成一个JavaScript文件。<br>然后，在页面上通过<script>标签把所有生成的JavaScript文件按正确的顺序引进来，比如：</p>
<p><code>MyTestPage.html (excerpt)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;Validation.js&quot; type=&quot;text/javascript&quot; /&gt;</div><div class="line">&lt;script src=&quot;LettersOnlyValidator.js&quot; type=&quot;text/javascript&quot; /&gt;</div><div class="line">&lt;script src=&quot;ZipCodeValidator.js&quot; type=&quot;text/javascript&quot; /&gt;</div><div class="line">&lt;script src=&quot;Test.js&quot; type=&quot;text/javascript&quot; /&gt;</div></pre></td></tr></table></figure>
<h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>另一种简化模块操作的方法是使用<code>import q = x.y.z</code>给常用的模块起一个短的名字。<br>不要与<code>import x = require(&#39;name&#39;)</code>用来加载模块的语法弄混了，这里的语法是为指定的符号创建一个别名。<br>你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">namespace Shapes &#123;</div><div class="line">    export namespace Polygons &#123;</div><div class="line">        export class Triangle &#123; &#125;</div><div class="line">        export class Square &#123; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">import polygons = Shapes.Polygons;</div><div class="line">var sq = new polygons.Square(); // Same as &quot;new Shapes.Polygons.Square()&quot;</div></pre></td></tr></table></figure>
<p>注意，我们并没有使用require关键字，而是直接使用导入符号的限定名赋值。<br>这与使用var相似，但它还适用于类型和导入的具有命名空间含义的符号。<br>重要的是，对于值来讲，import会生成与原始符号不同的引用，所以改变别名的值并不会影响原始变量的值。</p>
<h4 id="使用其它的JavaScript库"><a href="#使用其它的JavaScript库" class="headerlink" title="使用其它的JavaScript库"></a>使用其它的JavaScript库</h4><p>为了描述不是用TypeScript编写的类库的类型，我们需要声明类库导出的API。<br>由于大部分程序库只提供少数的顶级对象，命名空间是用来表示它们是一个好办法。</p>
<p>我们叫它声明因为它不是外部程序的具体实现。<br>通常会在<code>.d.ts</code>里写这些定义。<br>如果你熟悉C/C++，你可以把它们当做<code>.h</code>文件。<br>让我们看一些例子。</p>
<h4 id="外部命名空间"><a href="#外部命名空间" class="headerlink" title="外部命名空间"></a>外部命名空间</h4><p>流行的程序库D3在全局对象d3里定义它的功能。<br>因为这个库通过一个<script>标签加载（不是通过模块加载器），它的声明文件使用内部模块来定义它的类型。<br>为了让TypeScript编译器识别它的类型，我们使用外部命名空间声明。<br>比如，我们可以像下面这样写：</p>
<p><code>D3.d.ts</code> (部分摘录)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">declare namespace D3 &#123;</div><div class="line">    export interface Selectors &#123;</div><div class="line">        select: &#123;</div><div class="line">            (selector: string): Selection;</div><div class="line">            (element: EventTarget): Selection;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    export interface Event &#123;</div><div class="line">        x: number;</div><div class="line">        y: number;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    export interface Base extends Selectors &#123;</div><div class="line">        event: Event;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">declare var d3: D3.Base;</div></pre></td></tr></table></figure>
<p>关于术语的一点说明:   </p>
<blockquote>
<p>必须要注意一点在TypeScript 1.5里，术语名称已经发生了变化。<br><code>“Internal modules”</code>现在叫做 <code>“namespaces”</code>。<br><code>“External modules”</code> 现在则简称为 <code>“modules”</code>，为了与ECMAScript 2015里的术语保持一致，(也就是说 module X { 相当于现在推荐的写法 namespace X {)。</p>
<h3 id="模块-介绍"><a href="#模块-介绍" class="headerlink" title="模块 介绍"></a>模块 介绍</h3></blockquote>
<p>从ECMAScript 2015开始，JavaScript引入了模块的概念。TypeScript也沿用这个概念。</p>
<p>模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用export forms语法其中的一个导出它们。<br>相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用import 形式之一。</p>
<p>模块是自声明的；两个模块之间的关系是通过在文件级别上使用imports和exports建立的。</p>
<p>模块使用模块加载器去导入其它的模块。<br>在运行时，模块加载器的作用在执行此模块代码前去查找并执行这个模块的所有依赖。<br>大家最熟知的JavaScript模块加载器是服务于Node.js的CommonJS和服务于Web应用的require.js。</p>
<p>TypeScript与CMAScript 2015一样，任何包含顶级import或者export的文件都被当成一个模块。</p>
<h3 id="Export-导出"><a href="#Export-导出" class="headerlink" title="Export 导出"></a>Export 导出</h3><h4 id="导出声明"><a href="#导出声明" class="headerlink" title="导出声明"></a>导出声明</h4><p>任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加export关键字来导出。</p>
<p><code>Validation.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export interface StringValidator &#123;</div><div class="line">    isAcceptable(s: string): boolean;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ZipCodeValidator.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">export const numberRegexp = /^[0-9]+$/;</div><div class="line"></div><div class="line">export class ZipCodeValidator implements StringValidator &#123;</div><div class="line">    isAcceptable(s: string) &#123;</div><div class="line">        return s.length === 5 &amp;&amp; numberRegexp.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="导出语句"><a href="#导出语句" class="headerlink" title="导出语句"></a>导出语句</h4><p>导出语句很便利，因为我们可能需要对导出的部分重命名，所以上面的例子可以这样改写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class ZipCodeValidator implements StringValidator &#123;</div><div class="line">    isAcceptable(s: string) &#123;</div><div class="line">        return s.length === 5 &amp;&amp; numberRegexp.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">export &#123; ZipCodeValidator &#125;;</div><div class="line">export &#123; ZipCodeValidator as mainValidator &#125;;</div></pre></td></tr></table></figure>
<h4 id="重新导出"><a href="#重新导出" class="headerlink" title="重新导出"></a>重新导出</h4><p>我们经常会去扩展其它模块，并且只导出那个模块的部分内容。<br>重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。</p>
<p><code>ParseIntBasedZipCodeValidator.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">export class ParseIntBasedZipCodeValidator &#123;</div><div class="line">    isAcceptable(s: string) &#123;</div><div class="line">        return s.length === 5 &amp;&amp; parseInt(s).toString() === s;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 导出原先的验证器但做了重命名</div><div class="line">export &#123;ZipCodeValidator as RegExpBasedZipCodeValidator&#125; from &quot;./ZipCodeValidator&quot;;</div></pre></td></tr></table></figure>
<p>或者一个模块可以包裹多个模块，并把他们导出的内容联合在一起通过语法：<code>export * from &quot;module&quot;</code>。</p>
<p><code>AllValidators.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export * from &quot;./StringValidator&quot;; // exports interface StringValidator</div><div class="line">export * from &quot;./LettersOnlyValidator&quot;; // exports class LettersOnlyValidator</div><div class="line">export * from &quot;./ZipCodeValidator&quot;;  // exports class ZipCodeValidator</div></pre></td></tr></table></figure>
<h4 id="Import-导入"><a href="#Import-导入" class="headerlink" title="Import 导入"></a>Import 导入</h4><p>模块的导入操作与导出一样简单。<br>可以使用以下import形式之一来导入其它模块中的导出内容。</p>
<p>导入一个模块中的某一个export内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import &#123; ZipCodeValidator &#125; from &quot;./ZipCodeValidator&quot;;</div><div class="line"></div><div class="line">var myValidator = new ZipCodeValidator();</div></pre></td></tr></table></figure>
<h4 id="可以对导入内容重命名"><a href="#可以对导入内容重命名" class="headerlink" title="可以对导入内容重命名"></a>可以对导入内容重命名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; ZipCodeValidator as ZCV &#125; from &quot;./ZipCodeValidator&quot;;</div><div class="line">var myValidator = new ZCV();</div></pre></td></tr></table></figure>
<p>将整个模块导入到一个变量，并通过它来访问模块的导出部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import * as validator from &quot;./ZipCodeValidator&quot;;</div><div class="line">var myValidator = new validator.ZipCodeValidator();</div></pre></td></tr></table></figure>
<h4 id="具有副作用的导入模块"><a href="#具有副作用的导入模块" class="headerlink" title="具有副作用的导入模块"></a>具有副作用的导入模块</h4><p>尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。<br>这些模块可能没有任何的exports或用户根本就不关注它的exports。<br>使用下面的方法来导入这类模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &quot;./my-module.js&quot;;</div></pre></td></tr></table></figure>
<h4 id="Default-exports"><a href="#Default-exports" class="headerlink" title="Default exports"></a>Default exports</h4><p>每个模块都可以有一个<code>default</code>导出。<br>默认导出使用<code>default</code>关键字标记；并且一个模块只能够有一个<code>default</code>导出。<br>引入<code>default</code>导出的时候，需要使用另外一种导出形式。</p>
<p><code>default</code>导出十分便利。<br>比如，像JQuery这样的类库可能有一个默认导出jQuery或$，并且我们基本上也会使用同样的名字jQuery或$导出JQuery。</p>
<p><code>JQuery.d.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">declare var $: JQuery;</div><div class="line">export default $;</div></pre></td></tr></table></figure>
<p><code>App.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import $ from &quot;JQuery&quot;;</div><div class="line"></div><div class="line">$(&quot;button.continue&quot;).html( &quot;Next Step...&quot; );</div></pre></td></tr></table></figure>
<p>类和函数声明可以直接被标记为默认导出。<br>标记为默认导出的类和函数的名字是可以省略的。</p>
<p><code>ZipCodeValidator.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">export default class ZipCodeValidator &#123;</div><div class="line">    static numberRegexp = /^[0-9]+$/;</div><div class="line">    isAcceptable(s: string) &#123;</div><div class="line">        return s.length === 5 &amp;&amp; ZipCodeValidator.numberRegexp.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Test.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import validator from &quot;./ZipCodeValidator&quot;;</div><div class="line"></div><div class="line">var validator = new validator();</div></pre></td></tr></table></figure>
<p>或者</p>
<p><code>StaticZipCodeValidator.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const numberRegexp = /^[0-9]+$/;</div><div class="line"></div><div class="line">export default function (s: string) &#123;</div><div class="line">    return s.length === 5 &amp;&amp; numberRegexp.test(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Test.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import validate from &quot;./StaticZipCodeValidator&quot;;</div><div class="line"></div><div class="line">var strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];</div><div class="line"></div><div class="line">// Use function validate</div><div class="line">strings.forEach(s =&gt; &#123;</div><div class="line">  console.log(`&quot;$&#123;s&#125;&quot; $&#123;validate(s) ? &quot; matches&quot; : &quot; does not match&quot;&#125;`);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="default导出也可以是一个值"><a href="#default导出也可以是一个值" class="headerlink" title="default导出也可以是一个值"></a>default导出也可以是一个值</h4><p><code>OneTwoThree.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export default &quot;123&quot;;</div></pre></td></tr></table></figure>
<p><code>Log.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import num from &quot;./OneTwoThree&quot;;</div><div class="line"></div><div class="line">console.log(num); // &quot;123&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export = 和 import = require()</div></pre></td></tr></table></figure>
<p>CommonJS和AMD都有一个exports对象的概念，它包含了一个模块的所有导出内容。</p>
<p>它们也支持把exports替换为一个自定义对象。<br>默认导出就好比这样一个功能；然而，它们却并不相互兼容。<br>TypeScript模块支持export =语法，以配合传统的CommonJS和AMD的工作流。</p>
<p>export =语法定义一个模块的导出对象。<br>它可以是类，接口，命名空间，函数或枚举。</p>
<p>若要导入一个使用了export =的模块时，必须使用TypeScript提供的特定语法<code>import var = require(&quot;module&quot;)</code>。</p>
<p><code>ZipCodeValidator.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var numberRegexp = /^[0-9]+$/;</div><div class="line">class ZipCodeValidator &#123;</div><div class="line">    isAcceptable(s: string) &#123;</div><div class="line">        return s.length === 5 &amp;&amp; numberRegexp.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">export = ZipCodeValidator;</div></pre></td></tr></table></figure>
<p><code>Test.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import zip = require(&quot;./ZipCodeValidator&quot;);</div><div class="line"></div><div class="line">// Some samples to try</div><div class="line">var strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];</div><div class="line"></div><div class="line">// Validators to use</div><div class="line">var validator = new zip.ZipCodeValidator();</div><div class="line"></div><div class="line">// Show whether each string passed each validator</div><div class="line">strings.forEach(s =&gt; &#123;</div><div class="line">  console.log(`&quot;$&#123; s &#125;&quot; - $&#123; validator.isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; &#125;`);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="生成模块代码"><a href="#生成模块代码" class="headerlink" title="生成模块代码"></a>生成模块代码</h4><p>根据编译时指定的模块目标参数，编译器会生成相应的供<code>Node.js (CommonJS)，require.js (AMD)，isomorphic (UMD), SystemJS或ECMAScript 2015 native modules (ES6)</code>模块加载系统使用的代码。<br>想要了解生成代码中<code>define，require</code> 和 <code>register</code>的意义，请参考相应模块加载器的文档。</p>
<p>下面的例子说明了导入导出语句里使用的名字是怎么转换为相应的模块加载器代码的。</p>
<p><code>SimpleModule.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import m = require(&quot;mod&quot;);</div><div class="line">export var t = m.something + 1;</div></pre></td></tr></table></figure>
<p><code>AMD / RequireJS SimpleModule.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">define([&quot;require&quot;, &quot;exports&quot;, &quot;./mod&quot;], function (require, exports, mod_1) &#123;</div><div class="line">    exports.t = mod_1.something + 1;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>CommonJS / Node SimpleModule.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var mod_1 = require(&quot;./mod&quot;);</div><div class="line">exports.t = mod_1.something + 1;</div></pre></td></tr></table></figure>
<p><code>UMD SimpleModule.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(function (factory) &#123;</div><div class="line">    if (typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot;) &#123;</div><div class="line">        var v = factory(require, exports); if (v !== undefined) module.exports = v;</div><div class="line">    &#125;</div><div class="line">    else if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;</div><div class="line">        define([&quot;require&quot;, &quot;exports&quot;, &quot;./mod&quot;], factory);</div><div class="line">    &#125;</div><div class="line">&#125;)(function (require, exports) &#123;</div><div class="line">    var mod_1 = require(&quot;./mod&quot;);</div><div class="line">    exports.t = mod_1.something + 1;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>System SimpleModule.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">System.register([&quot;./mod&quot;], function(exports_1) &#123;</div><div class="line">    var mod_1;</div><div class="line">    var t;</div><div class="line">    return &#123;</div><div class="line">        setters:[</div><div class="line">            function (mod_1_1) &#123;</div><div class="line">                mod_1 = mod_1_1;</div><div class="line">            &#125;],</div><div class="line">        execute: function() &#123;</div><div class="line">            exports_1(&quot;t&quot;, t = mod_1.something + 1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Native ECMAScript 2015 modules SimpleModule.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; something &#125; from &quot;./mod&quot;;</div><div class="line">export var t = something + 1;</div></pre></td></tr></table></figure>
<h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><p>下面我们来整理一下前面的验证器实现，每个模块只有一个命名的导出。</p>
<p>为了编译，我们必需要在命令行上指定一个模块目标。对于Node.js来说，使用–<code>module commonjs</code>；<br>对于require.js来说，使用<code>--module amd</code>。比如：</p>
<p><code>tsc --module commonjs Test.ts</code></p>
<p>When compiled, each module will become a separate .js file.<br>As with reference tags, the compiler will follow import statements to compile dependent files.<br>编译完成后，每个模块会生成一个单独的.js文件。<br>好比使用了reference标签，编译器会根据import语句编译相应的文件。</p>
<p><code>Validation.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export interface StringValidator &#123;</div><div class="line">    isAcceptable(s: string): boolean;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LettersOnlyValidator.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import &#123; StringValidator &#125; from &quot;./Validation&quot;;</div><div class="line"></div><div class="line">const lettersRegexp = /^[A-Za-z]+$/;</div><div class="line"></div><div class="line">export class LettersOnlyValidator implements StringValidator &#123;</div><div class="line">    isAcceptable(s: string) &#123;</div><div class="line">        return lettersRegexp.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ZipCodeValidator.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import &#123; StringValidator &#125; from &quot;./Validation&quot;;</div><div class="line"></div><div class="line">const numberRegexp = /^[0-9]+$/;</div><div class="line"></div><div class="line">export class ZipCodeValidator implements StringValidator &#123;</div><div class="line">    isAcceptable(s: string) &#123;</div><div class="line">        return s.length === 5 &amp;&amp; numberRegexp.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Test.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import &#123; StringValidator &#125; from &quot;./Validation&quot;;</div><div class="line">import &#123; ZipCodeValidator &#125; from &quot;./ZipCodeValidator&quot;;</div><div class="line">import &#123; LettersOnlyValidator &#125; from &quot;./LettersOnlyValidator&quot;;</div><div class="line"></div><div class="line">// Some samples to try</div><div class="line">let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];</div><div class="line"></div><div class="line">// Validators to use</div><div class="line">let validators: &#123; [s: string]: StringValidator; &#125; = &#123;&#125;;</div><div class="line">validators[&quot;ZIP code&quot;] = new ZipCodeValidator();</div><div class="line">validators[&quot;Letters only&quot;] = new LettersOnlyValidator();</div><div class="line"></div><div class="line">// Show whether each string passed each validator</div><div class="line">strings.forEach(s =&gt; &#123;</div><div class="line">    for (var name in validators) &#123;</div><div class="line">        console.log(`&quot;$&#123; s &#125;&quot; - $&#123; validators[name].isAcceptable(s) </div><div class="line">        ? &quot;matches&quot; : &quot;does not match&quot; &#125; $&#123; name &#125;`);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="可选的模块加载和其它高级加载场景"><a href="#可选的模块加载和其它高级加载场景" class="headerlink" title="可选的模块加载和其它高级加载场景"></a>可选的模块加载和其它高级加载场景</h4><p>有时候，你只想在某种条件下才加载某个模块。<br>在TypeScript里，则使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且可以保证类型完全。</p>
<p>编译器会探测是否每个模块都会在生成的JavaScript中用到。<br>如果一个模块标识符只被当成是类型注解部分使用时并完全没有在表达式中使用时，就不会生成require这个模块的代码。<br>省略掉没有用到的引用对性能提升是很有益的，并同时提供了可选加载模块的能力。</p>
<p>这种模式的核心是<code>import id = require(&quot;...&quot;)</code>语句可以让我们访问模块导出的类型。<br>模块加载器会被动态调用（通过require），就像下面if代码块里那样。<br>它利用了省略引用的优化，所以模块只在被需要时加载。<br>为了让这个模块工作，一定要注意import定义的标识符只能在表示类型处使用（不能在会转换成JavaScript的地方）。</p>
<p>为了确保类型安全性，我们可以使用typeof关键字。<br>typeof关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。</p>
<p>示例：Node.js里的动态模块加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">declare var require;</div><div class="line"></div><div class="line">import &#123; ZipCodeValidator as Zip &#125; from &quot;./ZipCodeValidator&quot;;</div><div class="line"></div><div class="line">if (needZipValidation) &#123;</div><div class="line">    var x: typeof Zip = require(&quot;./ZipCodeValidator&quot;);</div><div class="line">    if (x.isAcceptable(&quot;.....&quot;)) &#123; /* ... */ &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例：require.js里的动态模块加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">declare var require;</div><div class="line"></div><div class="line">import &#123; ZipCodeValidator as Zip &#125; from &quot;./ZipCodeValidator&quot;;</div><div class="line"></div><div class="line">if (needZipValidation) &#123;</div><div class="line">    require([&quot;./ZipCodeValidator&quot;], (x: typeof Zip) =&gt; &#123;</div><div class="line">        if (x.isAcceptable(&quot;...&quot;)) &#123; /* ... */ &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例：System.js里的动态模块加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">declare var System;</div><div class="line"></div><div class="line">import &#123; ZipCodeValidator as Zip &#125; from &quot;./ZipCodeValidator&quot;;</div><div class="line"></div><div class="line">if (needZipValidation) &#123;</div><div class="line">    System.import(&quot;./ZipCodeValidator&quot;).then((x: typeof Zip) =&gt; &#123;</div><div class="line">        if (x.isAcceptable(&quot;...&quot;)) &#123; /* ... */ &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用其它的JavaScript库</p>
<p>为了描述不是用TypeScript编写的类库的类型，我们需要声明类库导出的API。</p>
<p>我们叫它声明因为它不是外部程序的具体实现。<br>通常会在.d.ts里写这些定义。<br>如果你熟悉C/C++，你可以把它们当做.h文件。<br>让我们看一些例子。</p>
<h4 id="外部模块"><a href="#外部模块" class="headerlink" title="外部模块"></a>外部模块</h4><p>在Node.js里大部分工作是通过加载一个或多个模块实现的。<br>我们可以使用顶级的export声明来为每个模块都定义一个.d.ts文件，但最好还是写在一个大的.d.ts文件里。<br>我们使用与构造一个外部命名空间相似的方法，但是这里使用module关键字并且把名字用引号括起来，方便之后import。<br>例如：</p>
<p><code>node.d.ts (simplified excerpt)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">declare module &quot;url&quot; &#123;</div><div class="line">    export interface Url &#123;</div><div class="line">        protocol?: string;</div><div class="line">        hostname?: string;</div><div class="line">        pathname?: string;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;</div><div class="line">&#125;</div><div class="line"></div><div class="line">declare module &quot;path&quot; &#123;</div><div class="line">    export function normalize(p: string): string;</div><div class="line">    export function join(...paths: any[]): string;</div><div class="line">    export var sep: string;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们可以/// <code>&lt;reference&gt; node.d.ts</code>并且使用<code>import url = require(&quot;url&quot;);</code>加载模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</div><div class="line">import * as URL from &quot;url&quot;;</div><div class="line">var myUrl = URL.parse(&quot;http://www.typescriptlang.org&quot;);</div></pre></td></tr></table></figure>
<h3 id="创建模块结构指导"><a href="#创建模块结构指导" class="headerlink" title="创建模块结构指导"></a>创建模块结构指导</h3><h4 id="尽可能地在顶层导出"><a href="#尽可能地在顶层导出" class="headerlink" title="尽可能地在顶层导出"></a>尽可能地在顶层导出</h4><p>用户应该更容易地使用你模块导出的内容。<br>嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。</p>
<p>从你的模块中导出一个命名空间就是一个增加嵌套的例子。<br>虽然命名空间有时候有它们的用处，在使用模块的时候它们额外地增加了一层。<br>这对用户来说是很不便的并且通常是多余的。</p>
<p><code>Static methods on an exported class have a similar problem - the class itself adds a layer of nesting. 
Unless it increases expressivity or intent in a clearly useful way, consider simply exporting a helper function.</code></p>
<p>导出类的静态方法也有同样的问题 - 这个类本身就增加了一层嵌套。<br>除非它能方便表述或便于清晰使用，否则请考虑直接导出一个辅助方法。</p>
<p>如果仅导出单个<code>class</code> 或 <code>function</code>，使用 <code>export default</code></p>
<p>就像“在顶层上导出”帮助减少用户使用的难度，一个默认的导出也能起到这个效果。<br>如果一个模块就是为了导出特定的内容，那么你应该考虑使用一个默认导出。<br>这会令模块的导入和使用变得些许简单。<br>比如：</p>
<p><code>MyClass.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export default class SomeType &#123;</div><div class="line">  constructor() &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MyFunc.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export default function getThing() &#123; return &apos;thing&apos;; &#125;</div></pre></td></tr></table></figure>
<p><code>Consumer.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import t from &quot;./MyClass&quot;;</div><div class="line">import f from &quot;./MyFunc&quot;;</div><div class="line">var x = new t();</div><div class="line">console.log(f());</div></pre></td></tr></table></figure>
<p>对用户来说这是最理想的。他们可以随意命名导入模块的类型（本例为t）并且不需要多余的（.）来找到相关对象。</p>
<p>如果要导出多个对象，把它们放在顶层里导出</p>
<p><code>MyThings.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export class SomeType &#123; /* ... */ &#125;</div><div class="line">export function someFunc() &#123; /* ... */ &#125;</div></pre></td></tr></table></figure>
<p>相反地，当导入的时候：</p>
<p>明确地列出导入的名字</p>
<p><code>Consumer.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import &#123; SomeType, SomeFunc &#125; from &quot;./MyThings&quot;;</div><div class="line">var x = new SomeType();</div><div class="line">var y = someFunc();</div></pre></td></tr></table></figure>
<p>使用命名空间导入模式当你要导出大量内容的时候</p>
<p><code>MyLargeModule.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export class Dog &#123; ... &#125;</div><div class="line">export class Cat &#123; ... &#125;</div><div class="line">export class Tree &#123; ... &#125;</div><div class="line">export class Flower &#123; ... &#125;</div></pre></td></tr></table></figure>
<p><code>Consumer.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import * as myLargeModule from &quot;./MyLargeModule.ts&quot;;</div><div class="line">var x = new myLargeModule.Dog();</div></pre></td></tr></table></figure>
<h4 id="使用重新导出进行扩展"><a href="#使用重新导出进行扩展" class="headerlink" title="使用重新导出进行扩展"></a>使用重新导出进行扩展</h4><p>你可能经常需要去扩展一个模块的功能。<br>JS里常用的一个模式是JQuery那样去扩展原对象。<br>如我们之前提到的，模块不会像全局命名空间对象那样去合并。<br>推荐的方案是不要去改变原来的对象，而是导出一个新的实体来提供并提的功能。</p>
<p>假设<code>Calculator.ts</code>模块里定义了一个简单的计算器实现。<br>这个模块同样提供了一个辅助函数来测试计算器的功能，通过传入一系列输入的字符串并在最后给出结果。</p>
<p><code>Calculator.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">export class Calculator &#123;</div><div class="line">    private current = 0;</div><div class="line">    private memory = 0;</div><div class="line">    private operator: string;</div><div class="line"></div><div class="line">    protected processDigit(digit: string, currentValue: number) &#123;</div><div class="line">        if (digit &gt;= &quot;0&quot; &amp;&amp; digit &lt;= &quot;9&quot;) &#123;</div><div class="line">            return currentValue * 10 + (digit.charCodeAt(0) - &quot;0&quot;.charCodeAt(0));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected processOperator(operator: string) &#123;</div><div class="line">        if ([&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;].indexOf(operator) &gt;= 0) &#123;</div><div class="line">            return operator;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected evaluateOperator(operator: string, left: number, right: number): number &#123;</div><div class="line">        switch (this.operator) &#123;</div><div class="line">            case &quot;+&quot;: return left + right;</div><div class="line">            case &quot;-&quot;: return left - right;</div><div class="line">            case &quot;*&quot;: return left * right;</div><div class="line">            case &quot;/&quot;: return left / right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private evaluate() &#123;</div><div class="line">        if (this.operator) &#123;</div><div class="line">            this.memory = this.evaluateOperator(this.operator, this.memory, this.current);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            this.memory = this.current;</div><div class="line">        &#125;</div><div class="line">        this.current = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public handelChar(char: string) &#123;</div><div class="line">        if (char === &quot;=&quot;) &#123;</div><div class="line">            this.evaluate();</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            let value = this.processDigit(char, this.current);</div><div class="line">            if (value !== undefined) &#123;</div><div class="line">                this.current = value;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                let value = this.processOperator(char);</div><div class="line">                if (value !== undefined) &#123;</div><div class="line">                    this.evaluate();</div><div class="line">                    this.operator = value;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        throw new Error(`Unsupported input: &apos;$&#123;char&#125;&apos;`);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public getResult() &#123;</div><div class="line">        return this.memory;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export function test(c: Calculator, input: string) &#123;</div><div class="line">    for (let i = 0; i &lt; input.length; i++) &#123;</div><div class="line">        c.handelChar(input[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    console.log(`result of &apos;$&#123;input&#125;&apos; is &apos;$&#123;c.getResult()&#125;&apos;`);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是使用导出的test函数来测试计算器。</p>
<p><code>TestCalculator.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import &#123; Calculator, test &#125; from &quot;./Calculator&quot;;</div><div class="line"></div><div class="line"></div><div class="line">var c = new Calculator();</div><div class="line">test(c, &quot;1+2*33/11=&quot;); // prints 9</div></pre></td></tr></table></figure>
<p>现在扩展它，添加支持输入其它进制（十进制以外），让我们来创建<code>ProgrammerCalculator.ts</code>。</p>
<p><code>ProgrammerCalculator.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import &#123; Calculator &#125; from &quot;./Calculator&quot;;</div><div class="line"></div><div class="line"></div><div class="line">class ProgrammerCalculator extends Calculator &#123;</div><div class="line">    static digits = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;</div><div class="line">    , &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;];</div><div class="line"></div><div class="line">    constructor(public base: number) &#123;</div><div class="line">        super();</div><div class="line">        if (base &lt;= 0 || base &gt; ProgrammerCalculator.digits.length) &#123;</div><div class="line">            throw new Error(&quot;base has to be within 0 to 16 inclusive.&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected processDigit(digit: string, currentValue: number) &#123;</div><div class="line">        if (ProgrammerCalculator.digits.indexOf(digit) &gt;= 0) &#123;</div><div class="line">            return currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Export the new extended calculator as Calculator</div><div class="line">export &#123; ProgrammerCalculator as Calculator &#125;;</div><div class="line"></div><div class="line">// Also, export the helper function</div><div class="line">export &#123; test &#125; from &quot;./Calculator&quot;;</div></pre></td></tr></table></figure>
<p>新的<code>ProgrammerCalculator</code>模块导出的API与原先的<code>Calculator</code>模块很相似，但却没有改变原模块里的对象。<br>下面是测试<code>ProgrammerCalculator</code>类的代码：</p>
<p><code>TestProgrammerCalculator.ts</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import &#123; Calculator, test &#125; from &quot;./ProgrammerCalculator&quot;;</div><div class="line"></div><div class="line"></div><div class="line">var c = new Calculator(2);</div><div class="line">test(c, &quot;001+010=&quot;); // prints 3</div></pre></td></tr></table></figure>
<h4 id="模块里不要使用命名空间"><a href="#模块里不要使用命名空间" class="headerlink" title="模块里不要使用命名空间"></a>模块里不要使用命名空间</h4><p>当初次进入基于模块的开发模式时，可能总会控制不住要将导出包裹在一个命名空间里。<br>模块具有其自己的作用域，并且只有导出的声明才会在模块外部可见。<br>记住这点，命名空间在使用模块时几乎没什么价值。</p>
<p>在组织方面，命名空间对于在全局作用域内对逻辑上相关的对象和类型进行分组是很便利的。<br>例如，在C#里，你会从<code>System.Collections</code>里找到所有集合的类型。<br>通过将类型有层次地组织在命名空间里，可以方便用户找到与使用那些类型。<br>然而，模块本身已经存在于文件系统之中，必要地。<br>我们必须通过路径和文件名找到它们，这已经提供了一种逻辑上的组织形式。<br>我们可以创建<code>/collections/generic/</code>文件夹，把相应模块放在这里面。</p>
<p>命名空间对解决全局作用域里命名冲突来说是很重要的。<br>比如，你可以有一个<code>My.Application.Customer.AddForm</code>和<code>My.Application.Order.AddForm</code>– 两个类型的名字相同，但命名空间不同。<br>然而，这对于模块来说却不是一个问题。<br>在一个模块里，没有理由两个对象拥有同一个名字。<br>从模块的使用角度来说，使用者会挑出他们用来引用模块的名字，所以也没有理由发生重名的情况。</p>
<p>更多关于模块和命名空间的资料查看<a href="./Namespaces and Modules.md">命名空间和模块</a><br>危险信号</p>
<p>以下均为模块结构上的危险信号。重新检查以确保你没有在对模块使用命名空间：</p>
<p><code>A file whose only top-level declaration is export namespace Foo { ... } (remove Foo and move everything ‘up’ a level)
A file that has a single export class or export function (consider using export default)
Multiple files that have the same export namespace Foo { at top-level (don’t think that these are going to combine into one Foo!)</code><br>文件的顶层声明是<code>export namespace Foo { ... }</code>（删除Foo并把所有内容向上层移动一层）<br>文件只有一个<code>export class</code>或<code>export function</code> （考虑使用export default）<br>多个文件的顶层具有同样的<code>export namespace Foo</code> { （不要以为这些会合并到一个Foo中！）</p>
<h3 id="函数-介绍"><a href="#函数-介绍" class="headerlink" title="函数 介绍"></a>函数 介绍</h3><p>函数是JavaScript应用程序的基础。<br>它帮助你实现抽象层，模拟类，信息隐藏和模块。<br>在TypeScript里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。<br>TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易的使用。</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。<br>你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。</p>
<p>通过下面的例子可以迅速回想起这两种JavaScript中的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Named function</div><div class="line">function add(x, y) &#123;</div><div class="line">  return x+y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Anonymous function</div><div class="line">var myAdd = function(x, y) &#123; return x+y; &#125;;</div></pre></td></tr></table></figure>
<p>在JavaScript里，函数可以可以使用函数体外部的变量。<br>当函数这么做时，我们说它‘捕获’了这些变量。<br>至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习JavaScript和TypeScript会很有帮助。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var z = 100;</div><div class="line"></div><div class="line">function addToZ(x, y) &#123;</div><div class="line">  return x+y+z;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h4><h5 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h5><p>让我们为上面那个函数添加类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function add(x: number, y: number): number &#123;</div><div class="line">  return x+y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myAdd = function(x: number, y: number): number &#123; return x+y; &#125;;</div></pre></td></tr></table></figure>
<p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。<br>TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。</p>
<h5 id="书写完整函数类型"><a href="#书写完整函数类型" class="headerlink" title="书写完整函数类型"></a>书写完整函数类型</h5><p>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myAdd: (x:number, y:number)=&gt;number =</div><div class="line">  function(x: number, y: number): number &#123; return x+y; &#125;;</div></pre></td></tr></table></figure>
<p>函数类型包含两部分：参数类型和返回值类型。<br>当写出完整函数类型的时候，这两部分都是需要的。<br>我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。<br>这个名字只是为了增加可读性。<br>我们也可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myAdd: (baseValue:number, increment:number)=&gt;number =</div><div class="line">  function(x: number, y: number): number &#123; return x+y; &#125;;</div></pre></td></tr></table></figure>
<p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p>
<p>第二部分是返回值类型。<br>对于返回值，我们在函数和返回值类型之前使用(=&gt;)符号，使之清晰明了。<br>如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为void而不能留空。</p>
<p>函数的类型只是由参数类型和返回值组成的。<br>函数中使用的捕获变量不会体现在类型里。<br>实际上，这些变量是函数的隐藏状态并不是组成API的一部分。</p>
<h4 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h4><p>尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// myAdd has the full function type</div><div class="line">var myAdd = function(x: number, y: number): number &#123; return x+y; &#125;;</div><div class="line"></div><div class="line">// The parameters `x` and `y` have the type number</div><div class="line">var myAdd: (baseValue:number, increment:number)=&gt;number =</div><div class="line">  function(x, y) &#123; return x+y; &#125;;</div></pre></td></tr></table></figure>
<p>这叫做‘按上下文归类’，是类型推论的一种。<br>它帮助我们更好地为程序指定类型。</p>
<h4 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h4><p>不同于JavaScript，TypeScript里每个函数参数都是必须的。<br>这并不是指参数一定是个非null值，而是编译器检查用户是否为每个参数都传入了值。<br>编译器还会假设只有这些参数会被传递进函数。<br>简短地说，传递给函数的参数数量必须与函数期望的参数数量一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function buildName(firstName: string, lastName: string) &#123;</div><div class="line">  return firstName + &quot; &quot; + lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var result1 = buildName(&quot;Bob&quot;);  // error, too few parameters</div><div class="line">var result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;);  // error, too many parameters</div><div class="line">var result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;);  // ah, just right</div></pre></td></tr></table></figure>
<p>JavaScript里，每个参数都是可选的，可传可不传。<br>没传参的时候，它的值就是undefined。<br>在TypeScript里我们可以在参数名旁使用?实现可选参数的功能。<br>比如，我们想让last name是可选的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function buildName(firstName: string, lastName?: string) &#123;</div><div class="line">  if (lastName)</div><div class="line">      return firstName + &quot; &quot; + lastName;</div><div class="line">  else</div><div class="line">      return firstName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var result1 = buildName(&quot;Bob&quot;);  // works correctly now</div><div class="line">var result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;);  // error, too many parameters</div><div class="line">var result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;);  // ah, just right</div></pre></td></tr></table></figure>
<p>可选参数必须在必须跟在必须参数后面。<br>如果上例我们想让first name是可选的，那么就必须调整它们的位置，把first name放在后面。</p>
<p>TypeScript里，我们还可以为可选参数设置默认值。<br>仍然修改上例，把last name的默认值设置为”Smith”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function buildName(firstName: string, lastName = &quot;Smith&quot;) &#123;</div><div class="line">  return firstName + &quot; &quot; + lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var result1 = buildName(&quot;Bob&quot;);  // works correctly now, also</div><div class="line">var result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;);  // error, too many parameters</div><div class="line">var result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;);  // ah, just right</div></pre></td></tr></table></figure>
<p>和可选参数一样，带默认值的参数也要放在必须参数后面。</p>
<p>可选参数与默认值参数共享参数类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function buildName(firstName: string, lastName?: string) &#123;</div></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function buildName(firstName: string, lastName = &quot;Smith&quot;) &#123;</div></pre></td></tr></table></figure>
<p>共享同样的类型<code>(firstName: string, lastName?: string) =&gt; string</code>。<br>默认参数的默认值消失了，只保留了它是一个可选参数的信息。</p>
<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。<br>有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。<br>在JavaScript里，你可以使用arguments来访问所有传入的参数。</p>
<p>在TypeScript里，你可以把所有参数收集到一个变量里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function buildName(firstName: string, ...restOfName: string[]) &#123;</div><div class="line">return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;);</div></pre></td></tr></table></figure>
<p>剩余参数会被当做个数不限的可选参数。<br>可以一个都没有，同样也可以有任意个。<br>编译器创建参数数组，名字是你在省略号（…）后面给定的名字，你可以在函数体内使用这个数组。</p>
<p>这个省略号也会在带有剩余参数的函数类型定义上使用到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function buildName(firstName: string, ...restOfName: string[]) &#123;</div><div class="line">return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName;</div></pre></td></tr></table></figure>
<h3 id="Lambda表达式和使用this"><a href="#Lambda表达式和使用this" class="headerlink" title="Lambda表达式和使用this"></a>Lambda表达式和使用this</h3><p>JavaScript里this的工作机制对JavaScript程序员来说已经是老生常谈了。<br>的确，学会如何使用它绝对是JavaScript编程中的一件大事。<br>由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清this工作机制并且当有bug的时候能够找出错误所在。<br>this的工作机制可以单独写一本书了，并确已有人这么做了。在这里，我们只介绍一些基础知识。</p>
<p>JavaScript里，this的值在函数被调用的时候才会指定。<br>这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。<br>众所周知这不是一件很简单的事，特别是函数当做回调函数使用的时候。</p>
<p>下面看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var deck = &#123;</div><div class="line">  suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</div><div class="line">  cards: Array(52),</div><div class="line">  createCardPicker: function() &#123;</div><div class="line">      return function() &#123;</div><div class="line">          var pickedCard = Math.floor(Math.random() * 52);</div><div class="line">          var pickedSuit = Math.floor(pickedCard / 13);</div><div class="line"></div><div class="line">          return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var cardPicker = deck.createCardPicker();</div><div class="line">var pickedCard = cardPicker();</div><div class="line"></div><div class="line">alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit);</div></pre></td></tr></table></figure>
<p>如果我们运行这个程序，会发现它并没有弹出对话框而是报错了。<br>因为createCardPicker返回的函数里的this被设置成了window而不是deck对象。<br>当你调用cardPicker()时会发生这种情况。这里没有对this进行动态绑定因此为window。（注意在严格模式下，会是undefined而不是window）。</p>
<p>为了解决这个问题，我们可以在函数被返回时就绑好正确的this。<br>这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。</p>
<p>我们把函数表达式变为使用lambda表达式（ () =&gt; {} ）。<br>这样就会在函数创建的时候就指定了‘this’值，而不是在函数调用的时候。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var deck = &#123;</div><div class="line">  suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</div><div class="line">  cards: Array(52),</div><div class="line">  createCardPicker: function() &#123;</div><div class="line">      // Notice: the line below is now a lambda, allowing us to capture `this` earlier</div><div class="line">      return () =&gt; &#123;</div><div class="line">          var pickedCard = Math.floor(Math.random() * 52);</div><div class="line">          var pickedSuit = Math.floor(pickedCard / 13);</div><div class="line"></div><div class="line">          return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var cardPicker = deck.createCardPicker();</div><div class="line">var pickedCard = cardPicker();</div><div class="line"></div><div class="line">alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit);</div></pre></td></tr></table></figure>
<p>为了解更多关于this的信息，请阅读Yahuda Katz的Understanding JavaScript Function Invocation and “this”。</p>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>JavaScript本身是个动态语言。<br>JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var suits = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];</div><div class="line"></div><div class="line">function pickCard(x): any &#123;</div><div class="line">  // Check to see if we&apos;re working with an object/array</div><div class="line">  // if so, they gave us the deck and we&apos;ll pick the card</div><div class="line">  if (typeof x == &quot;object&quot;) &#123;</div><div class="line">      var pickedCard = Math.floor(Math.random() * x.length);</div><div class="line">      return pickedCard;</div><div class="line">  &#125;</div><div class="line">  // Otherwise just let them pick the card</div><div class="line">  else if (typeof x == &quot;number&quot;) &#123;</div><div class="line">      var pickedSuit = Math.floor(x / 13);</div><div class="line">      return &#123; suit: suits[pickedSuit], card: x % 13 &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myDeck = [&#123; suit: &quot;diamonds&quot;, card: 2 &#125;</div><div class="line">            , &#123; suit: &quot;spades&quot;, card: 10 &#125;, &#123; suit: &quot;hearts&quot;, card: 4 &#125;];</div><div class="line">var pickedCard1 = myDeck[pickCard(myDeck)];</div><div class="line">alert(&quot;card: &quot; + pickedCard1.card + &quot; of &quot; + pickedCard1.suit);</div><div class="line"></div><div class="line">var pickedCard2 = pickCard(15);</div><div class="line">alert(&quot;card: &quot; + pickedCard2.card + &quot; of &quot; + pickedCard2.suit);</div></pre></td></tr></table></figure>
<p>pickCard方法根据传入参数的不同会返回两种不同的类型。<br>如果传入的是代表纸牌的对象，函数作用是从中抓一张牌。<br>如果用户想抓牌，我们告诉他抓到了什么牌。<br>但是这怎么在类型系统里表示呢。</p>
<p>方法是为同一个函数提供多个函数类型定义来进行函数重载。<br>编译器会根据这个列表去处理函数的调用。<br>下面我们来重载pickCard函数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var suits = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];</div><div class="line"></div><div class="line">function pickCard(x: &#123;suit: string; card: number; &#125;[]): number;</div><div class="line">function pickCard(x: number): &#123;suit: string; card: number; &#125;;</div><div class="line">function pickCard(x): any &#123;</div><div class="line">  // Check to see if we&apos;re working with an object/array</div><div class="line">  // if so, they gave us the deck and we&apos;ll pick the card</div><div class="line">  if (typeof x == &quot;object&quot;) &#123;</div><div class="line">      var pickedCard = Math.floor(Math.random() * x.length);</div><div class="line">      return pickedCard;</div><div class="line">  &#125;</div><div class="line">  // Otherwise just let them pick the card</div><div class="line">  else if (typeof x == &quot;number&quot;) &#123;</div><div class="line">      var pickedSuit = Math.floor(x / 13);</div><div class="line">      return &#123; suit: suits[pickedSuit], card: x % 13 &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myDeck = [&#123; suit: &quot;diamonds&quot;, card: 2 &#125;</div><div class="line">            , &#123; suit: &quot;spades&quot;, card: 10 &#125;, &#123; suit: &quot;hearts&quot;, card: 4 &#125;];</div><div class="line">var pickedCard1 = myDeck[pickCard(myDeck)];</div><div class="line">alert(&quot;card: &quot; + pickedCard1.card + &quot; of &quot; + pickedCard1.suit);</div><div class="line"></div><div class="line">var pickedCard2 = pickCard(15);</div><div class="line">alert(&quot;card: &quot; + pickedCard2.card + &quot; of &quot; + pickedCard2.suit);</div></pre></td></tr></table></figure>
<p>这样改变后，重载的pickCard函数在调用的时候会进行正确的类型检查。</p>
<p>为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。<br>它查找重载列表，尝试使用第一个重载定义。<br>如果匹配的话就使用这个。<br>因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p>
<p>注意，<code>function pickCard(x)</code>: any并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。<br>以其它参数调用pickCard会产生错误。</p>
<h3 id="泛型-介绍"><a href="#泛型-介绍" class="headerlink" title="泛型 介绍"></a>泛型 介绍</h3><p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。<br>组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。  </p>
<p>在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。<br>这样用户就可以以自己的数据类型来使用组件。</p>
<h4 id="泛型之Hello-World"><a href="#泛型之Hello-World" class="headerlink" title="泛型之Hello World"></a>泛型之Hello World</h4><p>下面来创建第一个使用泛型的例子：identity函数。<br>这个函数会返回任何传入它的值。<br>你可以把这个函数当成是echo命令。  </p>
<p>不用泛型的话，这个函数可能是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function identity(arg: number): number &#123;</div><div class="line">  return arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者，我们使用any类型来定义函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function identity(arg: any): any &#123;</div><div class="line">  return arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然使用any类型后这个函数已经能接收任何类型的arg参数，但是却丢失了一些信息：传入的类型与返回的类型应该是相同的。<br>如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p>
<p>因此，我们需要一种方法使用返回值的类型与传入参数的类型是相同的。<br>这里，我们使用了类型变量，它是一种特殊的变量，只用于表示类型而不是值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function identity&lt;T&gt;(arg: T): T &#123;</div><div class="line">  return arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们给identity添加了类型变量T。<br>T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。<br>之后我们再次使用了T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。<br>这允许我们跟踪函数里使用的类型的信息。</p>
<p>我们把这个版本的identity函数叫做泛型，因为它可以适用于多个类型。<br>不同于使用any，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p>
<p>我们定义了泛型函数后，可以用两种方法使用。<br>第一种是，传入所有的参数，包含类型参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var output = identity&lt;string&gt;(&quot;myString&quot;);  // type of output will be &apos;string&apos;</div></pre></td></tr></table></figure>
<p>这里我们明确的指定了T是字符串类型，并做为一个参数传给函数，使用了&lt;&gt;括起来而不是()。</p>
<p>第二种方法更普遍。利用了类型推论，编译器会根据传入的参数自动地帮助我们确定T的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var output = identity(&quot;myString&quot;);  // type of output will be &apos;string&apos;</div></pre></td></tr></table></figure>
<p>注意我们并没用&lt;&gt;明确的指定类型，编译器看到了myString，把T设置为此类型。<br>类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。</p>
<h3 id="使用泛型变量"><a href="#使用泛型变量" class="headerlink" title="使用泛型变量"></a>使用泛型变量</h3><p>使用泛型创建像identity这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。<br>换句话说，你必须把这些参数当做是任意或所有类型。</p>
<p>看下之前identity例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function identity&lt;T&gt;(arg: T): T &#123;</div><div class="line">  return arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们想同时打印出arg的长度。<br>我们很可能会这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</div><div class="line">  console.log(arg.length);  // Error: T doesn&apos;t have .length</div><div class="line">  return arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这么做，编译器会报错说我们使用了arg的.length属性，但是没有地方指明arg具有这个属性。<br>记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有.length属性的。</p>
<p>现在假设我们想操作T类型的数组而不直接是T。由于我们操作的是数组，所以.length属性是应该存在的。<br>我们可以像创建其它数组一样创建这个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123;</div><div class="line">  console.log(arg.length);  // Array has a .length, so no more error</div><div class="line">  return arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以这样理解loggingIdentity的类型：泛型函数loggingIdentity，接收类型参数T，和函数arg，它是个元素类型是T的数组，并返回元素类型是T的数组。<br>如果我们传入数字数组，将返回一个数字数组，因为此时T的的类型为number。<br>这可以让我们把泛型变量T当做类型的一部分使用，而不是整个类型，增加了灵活性。</p>
<p>我们也可以这样实现上面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123;</div><div class="line">  console.log(arg.length);  // Array has a .length, so no more error</div><div class="line">  return arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用过其它语言的话，你可能对这种语法已经很熟悉了。<br>在下一节，会介绍如何创建自定义泛型像Array<T>一样。</p>
<h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><p>上一节，我们创建了identity通用函数，可以适用于不同的类型。<br>在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p>
<p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function identity&lt;T&gt;(arg: T): T &#123;</div><div class="line">  return arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;</div></pre></td></tr></table></figure>
<p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function identity&lt;T&gt;(arg: T): T &#123;</div><div class="line">  return arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity;</div></pre></td></tr></table></figure>
<p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function identity&lt;T&gt;(arg: T): T &#123;</div><div class="line">  return arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity;</div></pre></td></tr></table></figure>
<p>这引导我们去写第一个泛型接口了。<br>我们把上面例子里的对象字面量拿出来做为一个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">interface GenericIdentityFn &#123;</div><div class="line">  &lt;T&gt;(arg: T): T;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function identity&lt;T&gt;(arg: T): T &#123;</div><div class="line">  return arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myIdentity: GenericIdentityFn = identity;</div></pre></td></tr></table></figure>
<p>一个相似的例子，我们可能想把泛型参数当作整个接口的一个参数。<br>这样我们就能清楚的知道使用的具体是哪个泛型类型（比如：Dictionary<string>而不只是Dictionary）。<br>这样接口里的其它成员也能知道这个参数的类型了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">interface GenericIdentityFn&lt;T&gt; &#123;</div><div class="line">  (arg: T): T;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function identity&lt;T&gt;(arg: T): T &#123;</div><div class="line">  return arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myIdentity: GenericIdentityFn&lt;number&gt; = identity;</div></pre></td></tr></table></figure>
<p>注意，我们的示例做了少许改动。<br>不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。<br>当我们使用<code>GenericIdentityFn</code>的时候，还得传入一个类型参数来指定泛型类型（这里是：number），锁定了之后代码里使用的类型。<br>理解何时把参数放在调用签名里和何时放在接口上是很有帮助的，对于描述哪部分类型属于泛型部分来说。</p>
<p>除了泛型接口，我们还可以创建泛型类。<br>注意，无法创建枚举泛型和命名空间泛型。</p>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>泛型类看上去与泛型接口差不多。<br>泛型类使用（&lt;&gt;）括起泛型类型，跟在类名后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class GenericNumber&lt;T&gt; &#123;</div><div class="line">  zeroValue: T;</div><div class="line">  add: (x: T, y: T) =&gt; T;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myGenericNumber = new GenericNumber&lt;number&gt;();</div><div class="line">myGenericNumber.zeroValue = 0;</div><div class="line">myGenericNumber.add = function(x, y) &#123; return x + y; &#125;;</div></pre></td></tr></table></figure>
<p>GenericNumber类的使用是十分直观的，并且你应该注意到了我们并不限制只能使用数字类型。<br>也可以使用字符串或其它更复杂的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var stringNumeric = new GenericNumber&lt;string&gt;();</div><div class="line">stringNumeric.zeroValue = &quot;&quot;;</div><div class="line">stringNumeric.add = function(x, y) &#123; return x + y; &#125;;</div><div class="line"></div><div class="line">alert(stringNumeric.add(stringNumeric.zeroValue, &quot;test&quot;));</div></pre></td></tr></table></figure>
<p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>
<p>我们在类那节说过，类有两部分：静态部分和实例部分。<br>泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p>
<h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。<br>在<code>loggingIdentity</code>例子中，我们想访问arg的length属性，但是编译器并不能证明每种类型都有length属性，所以就报错了。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</div><div class="line">  console.log(arg.length);  // Error: T doesn&apos;t have .length</div><div class="line">  return arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相比于操作any所有类型，我们想要限制函数去处理任意带有.length属性的所有类型。<br>只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。<br>为此，我们需要列出对于T的约束要求。</p>
<p>为此，我们定义一个接口来描述约束条件。<br>创建一个包含.length属性的接口，使用这个接口和extends关键字还实现约束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">interface Lengthwise &#123;</div><div class="line">  length: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</div><div class="line">  console.log(arg.length);  // Now we know it has a .length property, so no more error</div><div class="line">  return arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loggingIdentity(3);  // Error, number doesn&apos;t have a .length property</div></pre></td></tr></table></figure>
<p>我们需要传入符合约束类型的值，必须包含必须的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loggingIdentity(&#123;length: 10, value: 3&#125;);</div></pre></td></tr></table></figure>
<p>在泛型约束中使用类型参数</p>
<p>有时候，我们需要使用类型参数去约束另一个类型参数。比如，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function find&lt;T, U extends Findable&lt;T&gt;&gt;(n: T, s: U) &#123;   </div><div class="line">// errors because type parameter used in constraint</div><div class="line">// ...</div><div class="line">&#125;</div><div class="line">find (giraffe, myAnimals);</div></pre></td></tr></table></figure>
<p>可以通过下面的方法来实现，重写上面的代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function find&lt;T&gt;(n: T, s: Findable&lt;T&gt;) &#123;</div><div class="line">// ...</div><div class="line">&#125;</div><div class="line">find(giraffe, myAnimals);</div></pre></td></tr></table></figure>
<p>注意： 上面两种写法并不完全等同，因为第一段程序的返回值可能是U，而第二段程序却没有这一限制。</p>
<h4 id="在泛型里使用类类型"><a href="#在泛型里使用类类型" class="headerlink" title="在泛型里使用类类型"></a>在泛型里使用类类型</h4><p>在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function create&lt;T&gt;(c: &#123;new(): T; &#125;): T &#123;</div><div class="line">  return new c();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class BeeKeeper &#123;</div><div class="line">  hasMask: boolean;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ZooKeeper &#123;</div><div class="line">  nametag: string;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Animal &#123;</div><div class="line">  numLegs: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bee extends Animal &#123;</div><div class="line">  keeper: BeeKeeper;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Lion extends Animal &#123;</div><div class="line">  keeper: ZooKeeper;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function findKeeper&lt;A extends Animal, K&gt; (a: &#123;new(): A;</div><div class="line">  prototype: &#123;keeper: K&#125;&#125;): K &#123;</div><div class="line"></div><div class="line">  return a.prototype.keeper;</div><div class="line">&#125;</div><div class="line"></div><div class="line">findKeeper(Lion).nametag;  // typechecks!</div></pre></td></tr></table></figure>
<h3 id="混入-介绍"><a href="#混入-介绍" class="headerlink" title="混入 介绍"></a>混入 介绍</h3><p>除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。<br>你可能在Scala等语言里对mixins及其特性已经很熟悉了，但它在JavaScript中也是很流行的。</p>
<h4 id="混入示例"><a href="#混入示例" class="headerlink" title="混入示例"></a>混入示例</h4><p>下面的代码演示了如何在TypeScript里使用混入。<br>后面我们还会解释这段代码是怎么工作的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">// Disposable Mixin</div><div class="line">class Disposable &#123;</div><div class="line">  isDisposed: boolean;</div><div class="line">  dispose() &#123;</div><div class="line">      this.isDisposed = true;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// Activatable Mixin</div><div class="line">class Activatable &#123;</div><div class="line">  isActive: boolean;</div><div class="line">  activate() &#123;</div><div class="line">      this.isActive = true;</div><div class="line">  &#125;</div><div class="line">  deactivate() &#123;</div><div class="line">      this.isActive = false;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SmartObject implements Disposable, Activatable &#123;</div><div class="line">  constructor() &#123;</div><div class="line">      setInterval(() =&gt; console.log(this.isActive + &quot; : &quot; + this.isDisposed), 500);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  interact() &#123;</div><div class="line">      this.activate();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Disposable</div><div class="line">  isDisposed: boolean = false;</div><div class="line">  dispose: () =&gt; void;</div><div class="line">  // Activatable</div><div class="line">  isActive: boolean = false;</div><div class="line">  activate: () =&gt; void;</div><div class="line">  deactivate: () =&gt; void;</div><div class="line">&#125;</div><div class="line">applyMixins(SmartObject, [Disposable, Activatable])</div><div class="line"></div><div class="line">var smartObj = new SmartObject();</div><div class="line">setTimeout(() =&gt; smartObj.interact(), 1000);</div><div class="line"></div><div class="line">////////////////////////////////////////</div><div class="line">// In your runtime library somewhere</div><div class="line">////////////////////////////////////////</div><div class="line"></div><div class="line">function applyMixins(derivedCtor: any, baseCtors: any[]) &#123;</div><div class="line">  baseCtors.forEach(baseCtor =&gt; &#123;</div><div class="line">      Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123;</div><div class="line">          derivedCtor.prototype[name] = baseCtor.prototype[name];</div><div class="line">      &#125;)</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="理解这个例子"><a href="#理解这个例子" class="headerlink" title="理解这个例子"></a>理解这个例子</h4><p>代码里首先定义了两个类，它们将做为mixins。<br>可以看到每个类都只定义了一个特定的行为或功能。<br>稍后我们使用它们来创建一个新类，同时具有这两种功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// Disposable Mixin</div><div class="line">class Disposable &#123;</div><div class="line">  isDisposed: boolean;</div><div class="line">  dispose() &#123;</div><div class="line">      this.isDisposed = true;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// Activatable Mixin</div><div class="line">class Activatable &#123;</div><div class="line">  isActive: boolean;</div><div class="line">  activate() &#123;</div><div class="line">      this.isActive = true;</div><div class="line">  &#125;</div><div class="line">  deactivate() &#123;</div><div class="line">      this.isActive = false;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面创建一个类，结合了这两个mixins。<br>下面来看一下具体是怎么操作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class SmartObject implements Disposable, Activatable &#123;</div></pre></td></tr></table></figure>
<p>首先应该注意到的是，没使用extends而是使用implements。<br>把类当成了接口，仅使用Disposable和Activatable的类型而非其实现。<br>这意味着我们需要在类里面实现接口。<br>但是这是我们在用mixin时想避免的。</p>
<p>我们可以这么做来达到目的，为将要mixin进来的属性方法创建出占位属性。<br>这告诉编译器这些成员在运行时是可用的。<br>这样就能使用mixin带来的便利，虽说需要提前定义一些占位属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Disposable</div><div class="line">isDisposed: boolean = false;</div><div class="line">dispose: () =&gt; void;</div><div class="line">// Activatable</div><div class="line">isActive: boolean = false;</div><div class="line">activate: () =&gt; void;</div><div class="line">deactivate: () =&gt; void;</div></pre></td></tr></table></figure>
<p>最后，把mixins混入定义的类，完成全部实现部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">applyMixins(SmartObject, [Disposable, Activatable])</div></pre></td></tr></table></figure>
<p>最后，创建这个帮助函数，帮我们做混入操作。<br>它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function applyMixins(derivedCtor: any, baseCtors: any[]) &#123;</div><div class="line">  baseCtors.forEach(baseCtor =&gt; &#123;</div><div class="line">      Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123;</div><div class="line">          derivedCtor.prototype[name] = baseCtor.prototype[name];</div><div class="line">      &#125;)</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="声明合并-介绍"><a href="#声明合并-介绍" class="headerlink" title="声明合并 介绍"></a>声明合并 介绍</h4><p>TypeScript有一些独特的概念，有的是因为我们需要描述JavaScript顶级对象的类型发生了哪些变化。<br>这其中之一叫做声明合并。<br>理解了这个概念，对于你使用TypeScript去操作现有的JavaScript来说是大有帮助的。<br>同时，也会有助于理解更多高级抽象的概念。</p>
<p>首先，在了解如何进行声明合并之前，让我们先看一下什么叫做声明合并。</p>
<p>在这个手册里，声明合并是指编译器会把两个相同名字的声明合并成一个单独的声明。<br>合并后的声明同时具有那两个被合并的声明的特性。<br>声明合并不限于只合并两个，任意数量都可以。</p>
<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>Typescript中的声明会创建以下三种实体之一：命名空间，类型或者值。<br>用于创建命名空间的声明会新建一个命名空间：它包含了可以用（.）符号访问的一些名字。<br>用于创建类型的声明所做的是：用给定的名字和结构创建一种类型。<br>最后，创建值的声明就是那些可以在生成的JavaScript里看到的那部分（比如：函数和变量）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Declaration Type	Namespace	Type	Value</div><div class="line">Namespace	X		X</div><div class="line">Class		X	X</div><div class="line">Interface		X	</div><div class="line">Function			X</div><div class="line">Variable			X</div></pre></td></tr></table></figure>
<p>理解每个声明创建了什么，有助于理解当声明合并时什么东西被合并了。</p>
<p>理解了每种声明会对应创建什么对于理解如果进行声明合并是有帮助的。</p>
<h3 id="合并接口"><a href="#合并接口" class="headerlink" title="合并接口"></a>合并接口</h3><p>最简单最常见的就是合并接口，声明合并的种类是：接口合并。<br>从根本上说，合并的机制是把各自声明里的成员放进一个同名的单一接口里。</p>
<p><code>TypeScript</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">interface Box &#123; </div><div class="line">height: number; </div><div class="line">width: number; </div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Box &#123; </div><div class="line">scale: number; </div><div class="line">&#125;</div><div class="line"></div><div class="line">var box: Box = &#123;height: 5, width: 6, scale: 10&#125;;</div></pre></td></tr></table></figure>
<p>接口中非函数的成员必须是唯一的。如果多个接口中具有相同名字的非函数成员就会报错。</p>
<p>对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。</p>
<p>需要注意的是，接口A与它后面的接口A（把这个接口叫做A’）合并时，A’中的重载函数具有更高的优先级。</p>
<p>如下例所示：</p>
<p><code>TypeScript</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">interface Document &#123; </div><div class="line">createElement(tagName: any): Element; </div><div class="line">&#125; </div><div class="line">interface Document &#123; </div><div class="line">createElement(tagName: string): HTMLElement; </div><div class="line">&#125; </div><div class="line">interface Document &#123; </div><div class="line">createElement(tagName: &quot;div&quot;): HTMLDivElement; </div><div class="line">createElement(tagName: &quot;span&quot;): HTMLSpanElement; </div><div class="line">createElement(tagName: &quot;canvas&quot;): HTMLCanvasElement; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这三个接口合并成一个声明。<br>注意每组接口里的声明顺序保持不变，只是靠后的接口会出现在它前面的接口声明之前。</p>
<p><code>TypeScript</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">interface Document &#123; </div><div class="line">    createElement(tagName: &quot;div&quot;): HTMLDivElement; </div><div class="line">    createElement(tagName: &quot;span&quot;): HTMLSpanElement; </div><div class="line">    createElement(tagName: &quot;canvas&quot;): HTMLCanvasElement; </div><div class="line">    createElement(tagName: string): HTMLElement; </div><div class="line">    createElement(tagName: any): Element; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="合并命名空间"><a href="#合并命名空间" class="headerlink" title="合并命名空间"></a>合并命名空间</h3><p>与接口相似，同名的命名空间也会合并其成员。<br>命名空间会创建出命名空间和值，我们需要知道这两者都是怎么合并的。</p>
<p>命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。</p>
<p>值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里。</p>
<p>Animals声明合并示例：</p>
<p><code>TypeScript</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">namespace Animals &#123; </div><div class="line">export class Zebra &#123; &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">namespace Animals &#123; </div><div class="line">export interface Legged &#123; numberOfLegs: number; &#125; </div><div class="line">export class Dog &#123; &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等同于：</p>
<p><code>TypeScript</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">namespace Animals &#123; </div><div class="line">export interface Legged &#123; numberOfLegs: number; &#125;</div><div class="line"></div><div class="line">  export class Zebra &#123; &#125;</div><div class="line">  export class Dog &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了这些合并外，你还需要了解非导出成员是如何处理的。<br>非导出成员仅在其原始存在于的命名空间（未合并的）之内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员了。</p>
<p>下例提供了更清晰的说明：</p>
<p><code>TypeScript</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">namespace Animal &#123; </div><div class="line">var haveMuscles = true;</div><div class="line"></div><div class="line">  export function animalsHaveMuscles() &#123;</div><div class="line">      return haveMuscles;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">namespace Animal &#123; </div><div class="line">export function doAnimalsHaveMuscles() &#123; </div><div class="line">return haveMuscles; // &lt;– error, haveMuscles is not visible here </div><div class="line">&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为haveMuscles并没有导出，只有animalsHaveMuscles函数共享了原始未合并的命名空间可以访问这个变量。<br>doAnimalsHaveMuscles函数虽是合并命名空间的一部分，但是访问不了未导出的成员。</p>
<h3 id="命名空间与类和函数和枚举类型合并"><a href="#命名空间与类和函数和枚举类型合并" class="headerlink" title="命名空间与类和函数和枚举类型合并"></a>命名空间与类和函数和枚举类型合并</h3><p>命名空间可以与其它类型的声明进行合并。<br>只要命名空间的定义符合将要合并类型的定义。合并结果包含两者的声明类型。<br>Typescript使用这个功能去实现一些JavaScript里的设计模式。</p>
<p>首先，尝试将命名空间和类合并。<br>这让我们可以定义内部类。</p>
<p><code>TypeScript</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Album &#123; </div><div class="line">label: Album.AlbumLabel; </div><div class="line">&#125; </div><div class="line">namespace Album &#123; </div><div class="line">export class AlbumLabel &#123; &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>合并规则与上面合并命名空间小节里讲的规则一致，我们必须导出AlbumLabel类，好让合并的类能访问。<br>合并结果是一个类并带有一个内部类。<br>你也可以使用命名空间为类增加一些静态属性。</p>
<p>除了内部类的模式，你在JavaScript里，创建一个函数稍后扩展它增加一些属性也是很常见的。<br>Typescript使用声明合并来达到这个目的并保证类型安全。</p>
<p><code>TypeScript</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function buildLabel(name: string): string &#123; </div><div class="line">return buildLabel.prefix + name + buildLabel.suffix; </div><div class="line">&#125;</div><div class="line"></div><div class="line">namespace buildLabel &#123; </div><div class="line">export var suffix = “”; </div><div class="line">export var prefix = “Hello, “; </div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(buildLabel(“Sam Smith”));</div></pre></td></tr></table></figure>
<p>相似的，命名空间可以用来扩展枚举型：</p>
<p><code>TypeScript</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">enum Color &#123; </div><div class="line">red = 1, </div><div class="line">green = 2, </div><div class="line">blue = 4 </div><div class="line">&#125;</div><div class="line"></div><div class="line">namespace Color &#123; </div><div class="line">export function mixColor(colorName: string) &#123; </div><div class="line">if (colorName == “yellow”) &#123; </div><div class="line">return Color.red + Color.green; </div><div class="line">&#125; </div><div class="line">else if (colorName == “white”) &#123; </div><div class="line">return Color.red + Color.green + Color.blue; </div><div class="line">&#125; </div><div class="line">else if (colorName == “magenta”) &#123; </div><div class="line">return Color.red + Color.blue; </div><div class="line">&#125; </div><div class="line">else if (colorName == “cyan”) &#123; </div><div class="line">return Color.green + Color.blue; </div><div class="line">&#125; </div><div class="line">&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="非法的合并"><a href="#非法的合并" class="headerlink" title="非法的合并"></a>非法的合并</h3><p>并不是所有的合并都被允许。<br>现在，类不能与类合并，变量与类型不能合并，接口与类不能合并。<br>想要模仿类的合并，请参考Mixins in TypeScript。</p>
<h4 id="类型推论-介绍"><a href="#类型推论-介绍" class="headerlink" title="# 类型推论 介绍"></a># 类型推论 介绍</h4><p>这节介绍TypeScript里的类型推论。即，类型是在哪里如何被推断的。</p>
<h4 id="基础"><a href="#基础" class="headerlink" title="# 基础"></a># 基础</h4><p>TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var x = 3;</div></pre></td></tr></table></figure>
<p>变量x的类型被推断为数字。<br>这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p>
<p>大多数情况下，类型推论是直截了当地。<br>后面的小节，我们会浏览类型推论时的细微差别。</p>
<h4 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="# 最佳通用类型"></a># 最佳通用类型</h4><p>当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var x = [0, 1, null];</div></pre></td></tr></table></figure>
<p>为了推断x的类型，我们必须考虑所有元素的类型。<br>这里有两种选择：number和null。<br>计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p>
<p>由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var zoo = [new Rhino(), new Elephant(), new Snake()];</div></pre></td></tr></table></figure>
<p>这里，我们想让zoo被推断为Animal[]类型，但是这个数组里没有对象是Animal类型的，因此不能推断出这个结果。<br>为了更正，当候选类型不能使用的时候我们需要明确的指出类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];</div></pre></td></tr></table></figure>
<p>如果没有找到最佳通用类型的话，类型推论的结果是空对象类型，{}。<br>因为这个类型没有任何成员，所以访问其成员的时候会报错。</p>
<h4 id="上下文类型"><a href="#上下文类型" class="headerlink" title="# 上下文类型"></a># 上下文类型</h4><p>TypeScript类型推论也可能按照相反的方向进行。<br>这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">window.onmousedown = function(mouseEvent) &#123; </div><div class="line">console.log(mouseEvent.buton); //&lt;- Error </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个例子会得到一个类型错误，TypeScript类型检查器使用Window.onmousedown函数的类型来推断右边函数表达式的类型。<br>因此，就能推断出mouseEvent参数的类型了。<br>如果函数表达式不是在上下文类型的位置，mouseEvent参数的类型需要指定为any，这样也不会报错了。</p>
<p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。<br>重写上面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">window.onmousedown = function(mouseEvent: any) &#123; </div><div class="line">console.log(mouseEvent.buton); //&lt;- Now, no error is given </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。<br>这样的话就不报错了，因为这里不会使用到上下文类型。  </p>
<p>上下文归类会在很多情况下使用到。<br>通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。<br>上下文类型也会做为最佳通用类型的候选类型。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function createZoo(): Animal[] &#123; </div><div class="line">return [new Rhino(), new Elephant(), new Snake()]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子里，最佳通用类型有4个候选者：Animal，Rhino，Elephant和Snake。<br>当然，Animal会被做为最佳通用类型。</p>
<h4 id="类型兼容-介绍"><a href="#类型兼容-介绍" class="headerlink" title="# 类型兼容 介绍"></a># 类型兼容 介绍</h4><p>TypeScript里的类型兼容性基于结构子类型的。<br>结构类型是只一种只使用其成员来描述类型的方式。<br>它正好与名义类型形成对比。<br>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">interface Named &#123; </div><div class="line">name: string; </div><div class="line">&#125;</div><div class="line"></div><div class="line">class Person &#123; </div><div class="line">name: string; </div><div class="line">&#125;</div><div class="line"></div><div class="line">var p: Named; </div><div class="line">// OK, because of structural typing </div><div class="line">p = new Person();</div></pre></td></tr></table></figure>
<p>在使用名义类型的语言，比如C#或Java中，这段代码会报错，因为Person类没有明确说明其实现了Named接口。</p>
<p>TypeScript的结构性子类型是根据JavaScript代码的典型写法来设计的。<br>因为JavaScript里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。</p>
<h3 id="关于可靠性的注意事项"><a href="#关于可靠性的注意事项" class="headerlink" title="# 关于可靠性的注意事项"></a># 关于可靠性的注意事项</h3><p>TypeScript的类型系统允许一些在编译阶段无法否认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。</p>
<h4 id="开始"><a href="#开始" class="headerlink" title="# 开始"></a># 开始</h4><p>TypeScript结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的属性。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">interface Named &#123; </div><div class="line">name: string; </div><div class="line">&#125;</div><div class="line"></div><div class="line">var x: Named; </div><div class="line">// y’s inferred type is &#123; name: string; location: string; &#125; </div><div class="line">var y = &#123; name: ‘Alice’, location: ‘Seattle’ &#125;; </div><div class="line">x = y;</div></pre></td></tr></table></figure>
<p>这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。<br>在这个例子中，y必须包含名字是name的string类型成员。y满足条件，因此赋值正确。</p>
<p>检查函数参数时使用相同的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function greet(n: Named) &#123; </div><div class="line">alert(&apos;Hello, &apos; + n.name); </div><div class="line">&#125; </div><div class="line">greet(y); // OK</div></pre></td></tr></table></figure>
<p>注意，y有个额外的location属性，但这不会引发错误。<br>只有目标类型（这里是Named）的成员会被一一检查是否兼容。</p>
<p>这个比较过程是递归进行的，检查每个成员及子成员。</p>
<h4 id="比较两个函数"><a href="#比较两个函数" class="headerlink" title="# 比较两个函数"></a># 比较两个函数</h4><p>比较原始类型和对象类型时是容易理解的，问题是如何判断两个函数是兼容的。<br>让我们以两个函数开始，它们仅有参数列表不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var x = (a: number) =&gt; 0; </div><div class="line">var y = (b: number, s: string) =&gt; 0;</div><div class="line"></div><div class="line">y = x; // OK </div><div class="line">x = y; // Error</div></pre></td></tr></table></figure>
<p>要查看x是否能赋值给y，首先看它们的参数列表。<br>x的每个参数必须能在y里找到对应类型的参数。<br>注意的是参数的名字相同与否无所谓，只看它们的类型。<br>这里，x的每个参数在y中都能找到对应的参数，所以允许赋值。</p>
<p>第二个赋值错误，因为y有个必需的第二个参数，但是x并没有，所以不允许赋值。</p>
<p>你可能会疑惑为什么允许忽略参数，像例子y = x中那样。<br>原因是忽略额外的参数在JavaScript里是很常见的。<br>例如，Array#forEach给回调函数传3个参数：数组元素，索引和整个数组。<br>尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var items = [1, 2, 3];</div><div class="line"></div><div class="line">// Don’t force these extra arguments </div><div class="line">items.forEach((item, index, array) =&gt; console.log(item));</div><div class="line"></div><div class="line">// Should be OK! </div><div class="line">items.forEach((item) =&gt; console.log(item));</div></pre></td></tr></table></figure>
<p>下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var x = () =&gt; (&#123;name: ‘Alice’&#125;); </div><div class="line">var y = () =&gt; (&#123;name: ‘Alice’, location: ‘Seattle’&#125;);</div><div class="line"></div><div class="line">x = y; // OK </div><div class="line">y = x; // Error because x() lacks a location property</div></pre></td></tr></table></figure>
<p>类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。</p>
<h3 id="函数参数双向协变"><a href="#函数参数双向协变" class="headerlink" title="# 函数参数双向协变"></a># 函数参数双向协变</h3><p>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。<br>这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。<br>实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">enum EventType &#123; Mouse, Keyboard &#125;</div><div class="line"></div><div class="line">interface Event &#123; timestamp: number; &#125; </div><div class="line">interface MouseEvent extends Event &#123; x: number; y: number &#125; </div><div class="line">interface KeyEvent extends Event &#123; keyCode: number &#125;</div><div class="line"></div><div class="line">function listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) &#123; </div><div class="line">/* … */ </div><div class="line">&#125;</div><div class="line"></div><div class="line">// Unsound, but useful and common </div><div class="line">listenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x + ‘,’ + e.y));</div><div class="line"></div><div class="line">// Undesirable alternatives in presence of soundness </div><div class="line">listenEvent(EventType.Mouse, (e: Event) =&gt; console.log((e).x + ‘,’ + (e).y)); </div><div class="line">listenEvent(EventType.Mouse, &lt;(e: Event) =&gt; void&gt;((e: MouseEvent) </div><div class="line">=&gt; console.log(e.x + ‘,’ + e.y)));</div><div class="line"></div><div class="line">// Still disallowed (clear error). Type safety enforced for wholly incompatible types </div><div class="line">listenEvent(EventType.Mouse, (e: number) =&gt; console.log(e));</div></pre></td></tr></table></figure>
<h3 id="可选参数及剩余参数"><a href="#可选参数及剩余参数" class="headerlink" title="# 可选参数及剩余参数"></a># 可选参数及剩余参数</h3><p>比较函数兼容性的时候，可选参数与必须参数是可交换的。<br>原类型上额外的可选参数并不会造成错误，目标类型的可选参数没有对应的参数也不是错误。</p>
<p>当一个函数有剩余参数时，它被当做无限个可选参数。</p>
<p>这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些undefinded。</p>
<p>有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数但对类型系统来说是不确定的参数来调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function invokeLater(args: any[], callback: (…args: any[]) =&gt; void) &#123; </div><div class="line">/* … Invoke callback with ‘args’ … */ </div><div class="line">&#125;</div><div class="line"></div><div class="line">// Unsound - invokeLater “might” provide any number of arguments </div><div class="line">invokeLater([1, 2], (x, y) =&gt; console.log(x + ‘, ’ + y));</div><div class="line"></div><div class="line">// Confusing (x and y are actually required) and undiscoverable </div><div class="line">invokeLater([1, 2], (x?, y?) =&gt; console.log(x + ‘, ’ + y));</div></pre></td></tr></table></figure>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="# 函数重载"></a># 函数重载</h3><p>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。<br>这确保了目标函数可以在所有源函数可调用的地方调用。<br>对于特殊的函数重载签名不会用来做兼容性检查。</p>
<h4 id="枚举-1"><a href="#枚举-1" class="headerlink" title="# 枚举"></a># 枚举</h4><p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。比如，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum Status &#123; Ready, Waiting &#125;; </div><div class="line">enum Color &#123; Red, Blue, Green &#125;;</div><div class="line"></div><div class="line">var status = Status.Ready; </div><div class="line">status = Color.Green; //error</div></pre></td></tr></table></figure>
<h4 id="类-2"><a href="#类-2" class="headerlink" title="# 类"></a># 类</h4><p>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。<br>比较两个类类型的对象时，只有实例的成员会被比较。<br>静态成员和构造函数不在比较的范围内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Animal &#123; </div><div class="line">feet: number; </div><div class="line">constructor(name: string, numFeet: number) &#123; &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">class Size &#123; </div><div class="line">feet: number; </div><div class="line">constructor(numFeet: number) &#123; &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">var a: Animal; </div><div class="line">var s: Size;</div><div class="line"></div><div class="line">a = s; //OK </div><div class="line">s = a; //OK</div></pre></td></tr></table></figure>
<h3 id="类的私有成员"><a href="#类的私有成员" class="headerlink" title="# 类的私有成员"></a># 类的私有成员</h3><p>私有成员会影响兼容性判断。<br>当类的实例用来检查兼容时，如果它包含一个私有成员，那么目标类型必须包含来自同一个类的这个私有成员。<br>这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="# 泛型"></a># 泛型</h4><p>因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">interface Empty &#123; </div><div class="line">&#125; </div><div class="line">var x: Empty; </div><div class="line">var y: Empty;</div><div class="line"></div><div class="line">x = y; // okay, y matches structure of x</div></pre></td></tr></table></figure>
<p>上面代码里，x和y是兼容的，因为它们的结构使用类型参数时并没有什么不同。<br>把这个例子改变一下，增加一个成员，就能看出是如何工作的了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">interface NotEmpty &#123; </div><div class="line">data: T; </div><div class="line">&#125; </div><div class="line">var x: NotEmpty; </div><div class="line">var y: NotEmpty;</div><div class="line"></div><div class="line">x = y; // error, x and y are not compatible</div></pre></td></tr></table></figure>
<p>在这里，泛型类型在使用时就好比不是一个泛型类型。</p>
<p>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成any比较。<br>然后用结果类型进行比较，就像上面第一个例子。</p>
<p>比如，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var identity = function(x: T): T &#123; </div><div class="line">// … </div><div class="line">&#125;</div><div class="line"></div><div class="line">var reverse = function(y: U): U &#123; </div><div class="line">// … </div><div class="line">&#125;</div><div class="line"></div><div class="line">identity = reverse; // Okay because (x: any)=&gt;any matches (y: any)=&gt;any</div></pre></td></tr></table></figure>
<h3 id="高级主题"><a href="#高级主题" class="headerlink" title="# 高级主题"></a># 高级主题</h3><h4 id="子类型与赋值"><a href="#子类型与赋值" class="headerlink" title="# 子类型与赋值"></a># 子类型与赋值</h4><p>目前为止，我们使用了兼容性，它在语言规范里没有定义。<br>在TypeScript里，有两种类型的兼容性：子类型与赋值。<br>它们的不同点在于，赋值扩展了子类型兼容，允许给any赋值或从any取值和允许数字赋值给枚举类型或枚举类型赋值给数字。</p>
<p>语言里的不同地方分别使用了它们之中的机制。<br>实际上，类型兼容性是由赋值兼容性来控制的甚至在implements和extends语句里。<br>更多信息，请参阅TypeScript语言规范.</p>
<h3 id="d-ts文件-介绍"><a href="#d-ts文件-介绍" class="headerlink" title="# .d.ts文件 介绍"></a># .d.ts文件 介绍</h3><p>当使用外部JavaScript库或新的宿主API时，你需要一个声明文件（.d.ts）定义程序库的shape。<br>这个手册包含了写.d.ts文件的高级概念，并带有一些例子，告诉你怎么去写一个声明文件。</p>
<h3 id="指导与说明"><a href="#指导与说明" class="headerlink" title="# 指导与说明"></a># 指导与说明</h3><h4 id="流程"><a href="#流程" class="headerlink" title="# 流程"></a># 流程</h4><p>最好从程序库的文档开始写.d.ts文件，而不是代码。<br>这样保证不会被具体实现所干扰，而且相比于JS代码更易读。<br>下面的例子会假设你正在参照文档写声明文件。</p>
<h4 id="命名空间-1"><a href="#命名空间-1" class="headerlink" title="# 命名空间"></a># 命名空间</h4><p>当定义接口（例如：“options”对象），你会选择是否将这些类型放进命名空间里。<br>这主要是靠主观判断 – 使用的人主要是用这些类型声明变量和参数，并且类型命名不会引起命名冲突，放在全局命名空间里更好。<br>如果类型不是被直接使用，或者没法起一个唯一的名字的话，就使用命名空间来避免与其它类型发生冲突。</p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="# 回调函数"></a># 回调函数</h4><p>许多JavaScript库接收一个函数做为参数，之后传入已知的参数来调用它。<br>当为这些类型与函数签名的时候，不要把这个参数标记成可选参数。<br>正确的思考方式是“会提供什么样的参数？”，不是“会使用到什么样的参数？”。<br>TypeScript 0.9.7+不会强制这种可选参数的使用，参数可选的双向协变可以被外部的linter强制执行。</p>
<h4 id="扩展与声明合并"><a href="#扩展与声明合并" class="headerlink" title="# 扩展与声明合并"></a># 扩展与声明合并</h4><p>写声明文件的时候，要记住TypeScript扩展现有对象的方式。<br>你可以选择用匿名类型或接口类型的方式声明一个变量：</p>
<h4 id="匿名类型var"><a href="#匿名类型var" class="headerlink" title="匿名类型var"></a>匿名类型var</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">declare var MyPoint: &#123; x: number; y: number; &#125;;</div></pre></td></tr></table></figure>
<h4 id="接口类型var"><a href="#接口类型var" class="headerlink" title="接口类型var"></a>接口类型var</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">interface SomePoint &#123; x: number; y: number; &#125; </div><div class="line">declare var MyPoint: SomePoint;</div></pre></td></tr></table></figure>
<p>从使用者角度来讲，它们是相同的，但是SomePoint类型能够通过接口合并来扩展：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">interface SomePoint &#123; z: number; &#125; </div><div class="line">MyPoint.z = 4; // OK</div></pre></td></tr></table></figure>
<p>是否想让你的声明是可扩展的取决于主观判断。<br>通常来讲，尽量符合library的意图。</p>
<h3 id="类的分解"><a href="#类的分解" class="headerlink" title="# 类的分解"></a># 类的分解</h3><p>TypeScript的类会创建出两个类型：实例类型，定义了类型的实例具有哪些成员；构造函数类型，定义了类构造函数具有哪些类型。<br>构造函数类型也被称做类的静态部分类型，因为它包含了类的静态成员。</p>
<p>你可以使用typeof关键字来拿到类静态部分类型，在写声明文件时，想要把类明确的分解成实例类型和静态类型时是有用且必要的。</p>
<p>下面是一个例子，从使用者的角度来看，这两个声明是等同的：</p>
<h4 id="标准版"><a href="#标准版" class="headerlink" title="标准版"></a>标准版</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class A &#123; </div><div class="line">static st: string; </div><div class="line">inst: number; </div><div class="line">constructor(m: any) &#123;&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="分解版"><a href="#分解版" class="headerlink" title="分解版"></a>分解版</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">interface A_Static &#123; </div><div class="line">new(m: any): A_Instance; </div><div class="line">st: string; </div><div class="line">&#125; </div><div class="line">interface A_Instance &#123; </div><div class="line">inst: number; </div><div class="line">&#125; </div><div class="line">declare var A: A_Static;</div></pre></td></tr></table></figure>
<p>这里的利弊如下： </p>
<ul>
<li>标准方式可以使用extends来继承；分解的类不能。这可能会在未来版本的TypeScript里改变：是否允许任何的extends表达式 </li>
<li>都允许之后为类添加静态成员 </li>
<li>允许为分解的类再添加实例成员，标准版不允许 </li>
<li>使用分解类的时候，为成员起合理的名字</li>
</ul>
<h4 id="命名规则"><a href="#命名规则" class="headerlink" title="# 命名规则"></a># 命名规则</h4><p>一般来讲，不要给接口加I前缀（比如：IColor）。<br>类为TypeScript里的接口类型比C#或Java里的意义更为广泛，IFoo命名不利于这个特点。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="# 例子"></a># 例子</h3><p>下面进行例子部分。对于每个例子，先是使用使用方法，然后是类型声明。<br>如果有多个好的声明表示方法，会列出多个。</p>
<h4 id="参数对象"><a href="#参数对象" class="headerlink" title="# 参数对象"></a># 参数对象</h4><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">animalFactory.create(&quot;dog&quot;); </div><div class="line">animalFactory.create(&quot;giraffe&quot;, &#123; name: &quot;ronald&quot; &#125;); </div><div class="line">animalFactory.create(&quot;panda&quot;, &#123; name: &quot;bob&quot;, height: 400 &#125;); </div><div class="line">// Invalid: name must be provided if options is given </div><div class="line">animalFactory.create(&quot;cat&quot;, &#123; height: 32 &#125;);</div></pre></td></tr></table></figure>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">namespace animalFactory &#123; </div><div class="line">interface AnimalOptions &#123; </div><div class="line">name: string; </div><div class="line">height?: number; </div><div class="line">weight?: number; </div><div class="line">&#125; </div><div class="line">function create(name: string, animalOptions?: AnimalOptions): Animal; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="带属性的函数"><a href="#带属性的函数" class="headerlink" title="# 带属性的函数"></a># 带属性的函数</h4><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zooKeeper.workSchedule = &quot;morning&quot;; </div><div class="line">zooKeeper(giraffeCage);</div></pre></td></tr></table></figure>
<h4 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Note: Function must precede namespace </div><div class="line">function zooKeeper(cage: AnimalCage); </div><div class="line">namespace zooKeeper &#123; </div><div class="line">var workSchedule: string; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="可以用new调用也可以直接调用的方法"><a href="#可以用new调用也可以直接调用的方法" class="headerlink" title="# 可以用new调用也可以直接调用的方法"></a># 可以用new调用也可以直接调用的方法</h4><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var w = widget(32, 16); </div><div class="line">var y = new widget(&quot;sprocket&quot;); </div><div class="line">// w and y are both widgets </div><div class="line">w.sprock(); </div><div class="line">y.sprock();</div></pre></td></tr></table></figure>
<h4 id="类型-2"><a href="#类型-2" class="headerlink" title="类型"></a>类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">interface Widget &#123; </div><div class="line">sprock(): void; </div><div class="line">&#125;</div><div class="line"></div><div class="line">interface WidgetFactory &#123; </div><div class="line">new(name: string): Widget; </div><div class="line">(width: number, height: number): Widget; </div><div class="line">&#125;</div><div class="line"></div><div class="line">declare var widget: WidgetFactory;</div></pre></td></tr></table></figure>
<h4 id="全局的-不清楚的Libraries"><a href="#全局的-不清楚的Libraries" class="headerlink" title="# 全局的/不清楚的Libraries"></a># 全局的/不清楚的Libraries</h4><h4 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Either </div><div class="line">import x = require(&apos;zoo&apos;); </div><div class="line">x.open(); </div><div class="line">// or </div><div class="line">zoo.open();</div></pre></td></tr></table></figure>
<h4 id="类型-3"><a href="#类型-3" class="headerlink" title="类型"></a>类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">namespace zoo &#123; </div><div class="line">function open(): void; </div><div class="line">&#125;</div><div class="line"></div><div class="line">declare module “zoo” &#123; </div><div class="line">export = zoo; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="外部模块的单个复杂对象"><a href="#外部模块的单个复杂对象" class="headerlink" title="# 外部模块的单个复杂对象"></a># 外部模块的单个复杂对象</h4><h4 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// Super-chainable library for eagles </div><div class="line">import eagle = require(&apos;./eagle&apos;); </div><div class="line">// Call directly </div><div class="line">eagle(&apos;bald&apos;).fly(); </div><div class="line">// Invoke with new </div><div class="line">var eddie = new eagle(1000); </div><div class="line">// Set properties </div><div class="line">eagle.favorite = &apos;golden&apos;;</div></pre></td></tr></table></figure>
<h4 id="类型-4"><a href="#类型-4" class="headerlink" title="类型"></a>类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Note: can use any name here, but has to be the same throughout this file </div><div class="line">declare function eagle(name: string): eagle; </div><div class="line">declare namespace eagle &#123; </div><div class="line">var favorite: string; </div><div class="line">function fly(): void; </div><div class="line">&#125; </div><div class="line">interface eagle &#123; </div><div class="line">new(awesomeness: number): eagle; </div><div class="line">&#125;</div><div class="line"></div><div class="line">export = eagle;</div></pre></td></tr></table></figure>
<h4 id="回调函数-1"><a href="#回调函数-1" class="headerlink" title="# 回调函数"></a># 回调函数</h4><h4 id="使用方法-5"><a href="#使用方法-5" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addLater(3, 4, x =&gt; console.log(&apos;x = &apos; + x));</div></pre></td></tr></table></figure>
<h4 id="类型-5"><a href="#类型-5" class="headerlink" title="类型"></a>类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Note: &apos;void&apos; return type is preferred here </div><div class="line">function addLater(x: number, y: number, (sum: number) =&gt; void): void;</div></pre></td></tr></table></figure>
<p>如果你想看其它模式的实现方式，请在这里留言！<br>我们会尽可能地加到这里来。</p>
</script></p>
      
    </div>
    
    
    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/typescript/" rel="tag"># typescript</a>
          
            <a href="/tags/手册/" rel="tag"># 手册</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/06/20/16年/闭包详解/" rel="next" title="闭包详解">
                <i class="fa fa-chevron-left"></i> 闭包详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/20/17年/webpack插件编写/" rel="prev" title="webpack插件编写">
                webpack插件编写 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    石进华
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2016/07/02/16年/typescript中文手册/" title="typescript中文手册">http://yoursite.com/2016/07/02/16年/typescript中文手册/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=2123225" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>

          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3929251423,454148251&fm=27&gp=0.jpg"
              alt="石进华" />
          
            <p class="site-author-name" itemprop="name">石进华</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/mynane" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础类型"><span class="nav-number">1.</span> <span class="nav-text">基础类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#布尔值"><span class="nav-number">1.1.</span> <span class="nav-text">布尔值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数字"><span class="nav-number">1.2.</span> <span class="nav-text">数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">1.3.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组"><span class="nav-number">1.4.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#枚举"><span class="nav-number">1.5.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#任意值"><span class="nav-number">1.6.</span> <span class="nav-text">任意值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空值"><span class="nav-number">1.7.</span> <span class="nav-text">空值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口"><span class="nav-number">2.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口初探"><span class="nav-number">2.1.</span> <span class="nav-text">接口初探</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可选属性"><span class="nav-number">2.2.</span> <span class="nav-text">可选属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数类型"><span class="nav-number">2.3.</span> <span class="nav-text">函数类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组类型"><span class="nav-number">2.4.</span> <span class="nav-text">数组类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类类型"><span class="nav-number">2.5.</span> <span class="nav-text">类类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现接口"><span class="nav-number">2.6.</span> <span class="nav-text">实现接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩展接口"><span class="nav-number">2.7.</span> <span class="nav-text">扩展接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#混合类型"><span class="nav-number">2.8.</span> <span class="nav-text">混合类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口继承类"><span class="nav-number">2.9.</span> <span class="nav-text">接口继承类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类"><span class="nav-number">3.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类-1"><span class="nav-number">3.1.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承"><span class="nav-number">3.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#公共，私有与受保护的修饰符"><span class="nav-number">3.3.</span> <span class="nav-text">公共，私有与受保护的修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#默认为公有"><span class="nav-number">3.3.1.</span> <span class="nav-text">默认为公有</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#理解private"><span class="nav-number">3.3.2.</span> <span class="nav-text">理解private</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#理解protected"><span class="nav-number">3.3.3.</span> <span class="nav-text">理解protected</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#参数属性"><span class="nav-number">3.3.4.</span> <span class="nav-text">参数属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#存取器"><span class="nav-number">3.3.5.</span> <span class="nav-text">存取器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态属性"><span class="nav-number">3.3.6.</span> <span class="nav-text">静态属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高级技巧"><span class="nav-number">3.4.</span> <span class="nav-text">高级技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#构造函数"><span class="nav-number">3.4.1.</span> <span class="nav-text">构造函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#把类当做接口使用"><span class="nav-number">3.5.</span> <span class="nav-text">把类当做接口使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用命名空间"><span class="nav-number">4.</span> <span class="nav-text">使用命名空间</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 &mdash; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">石进华</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

<script>!function(t){function n(n){var e=n.getBoundingClientRect();return e.top>=0&&e.left>=0&&e.top<=(t.innerHeight||document.documentElement.clientHeight)}function e(t,n){var e=new Image,i=t.getAttribute("data-original");e.onload=function(){t.src=i,n&&n()},e.src=i}function i(){for(var t=0;t<o.length;t++)n(o[t])&&e(o[t],function(){o.splice(t,t)})}var o=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));i(),t.addEventListener("scroll",i)}(this);</script></body>
</html>
